<!DOCTYPE html>
<html lang="it">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Foosball Lab</title>

    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="default">
    <meta name="apple-mobile-web-app-title" content="Foosball Lab">
    <meta name="mobile-web-app-capable" content="yes">
    <meta name="theme-color" content="#f8f9fa">
    <link rel="manifest" href="manifest.json">

    <link rel="apple-touch-icon" href="foosball_16.png">
    <link rel="icon" type="image/png" sizes="32x32" href="foosball_16.png">
    <link rel="icon" type="image/png" sizes="16x16" href="foosball_16.png">

    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">
    <style>
        :root {
            --bg-neutral: #f8f9fa;
            --text-neutral: #212529;
            --text-muted: #6c757d;
            --border-color: #dee2e6;
            --card-bg: #ffffff;
            --team-blue: #148cb4;
            --team-blue-dark: #106f8f;
            --team-red: #dc3545;
            --team-red-dark: #b02a37;
            --accent: #FFD22E;
            --accent-dark: #f0c01a;
            --success: #28a745;
        }
        body {
            font-family: 'Inter', sans-serif;
            background-color: var(--bg-neutral);
            color: var(--text-neutral);
        }
        .card {
            background-color: var(--card-bg);
            border-radius: 0.75rem; /* rounded-xl */
            padding: 1.5rem; /* p-6 */
            box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.1), 0 2px 4px -2px rgba(0, 0, 0, 0.1);
        }
        .btn {
            display: inline-block;
            padding: 0.75rem 1.5rem;
            border-radius: 0.5rem;
            font-weight: 600;
            text-align: center;
            transition: all 0.2s ease-in-out;
            cursor: pointer;
            border: 1px solid transparent;
            -webkit-tap-highlight-color: transparent;
        }
        .btn-primary {
            background-color: var(--accent);
            color: var(--text-neutral);
            font-weight: 700;
        }
        .btn-primary:hover {
            background-color: var(--accent-dark);
            transform: translateY(-2px);
            box-shadow: 0 4px 8px rgba(0,0,0,0.1);
        }
        .btn-secondary {
            background-color: var(--team-blue);
            color: white;
        }
        .btn-secondary:hover {
            background-color: var(--team-blue-dark);
        }
        .btn:disabled {
            background-color: #e9ecef;
            color: #adb5bd;
            cursor: not-allowed;
            transform: none;
            box-shadow: none;
        }
        .btn-danger {
            background-color: var(--team-red);
            color: white;
        }
         .btn-danger:hover {
            background-color: var(--team-red-dark);
        }
        select, input[type="text"], input[type="date"], input[type="number"], input[type="password"] {
            background-color: #fff;
            border: 1px solid var(--border-color);
            color: var(--text-neutral);
            border-radius: 0.5rem;
            padding: 0.5rem 0.75rem;
            width: 100%;
        }
        select:focus, input:focus {
            outline: none;
            border-color: var(--accent);
            box-shadow: 0 0 0 3px rgba(255, 210, 46, 0.25);
        }
        .team-blue-color { color: var(--team-blue); }
        .team-red-color { color: var(--team-red); }
        .accordion-content {
            overflow: hidden;
            transition: max-height 0.3s ease-out;
        }
        .sort-btn svg {
            transition: transform 0.3s ease;
        }
        .modal-tab {
            cursor: pointer;
            padding: 0.5rem 1rem;
            border-bottom: 3px solid transparent;
            font-weight: 600;
            color: var(--text-muted);
        }
        .modal-tab.active {
            color: var(--team-blue);
            border-bottom-color: var(--team-blue);
        }
        .role-label {
            display: block;
            font-size: 0.75rem;
            font-weight: 500;
            color: var(--text-muted);
            margin-bottom: 0.25rem;
        }
        .rank-1 { background-color: rgba(255, 210, 46, 0.2); border-left: 4px solid var(--accent); }
        .rank-2 { background-color: rgba(192, 192, 192, 0.2); border-left: 4px solid #adb5bd; }
        .rank-3 { background-color: rgba(205, 127, 50, 0.15); border-left: 4px solid #CD7F32; }
        .wizard-action-card {
            border: 1px solid var(--border-color);
            border-radius: 0.5rem;
            padding: 1rem;
            text-align: left;
            transition: all 0.2s ease-in-out;
            cursor: pointer;
        }
        .wizard-action-card:hover {
            border-color: var(--team-blue);
            background-color: #f8f9fa;
            transform: translateY(-2px);
        }
        body.modal-open {
            overflow: hidden;
        }
        /* Tournament Bracket Styles */
        .tournament-bracket { display: flex; overflow-x: auto; padding: 20px; }
        .round { display: flex; flex-direction: column; justify-content: space-around; flex: 1; }
        .match { display: flex; flex-direction: column; justify-content: center; position: relative; margin: 20px 0; padding: 10px; background-color: rgba(0,0,0,0.02); border-radius: 8px; border: 1px solid transparent; cursor: pointer; transition: all 0.2s ease; }
        .match:hover { border-color: var(--accent); }
        .team { padding: 8px; border: 1px solid var(--border-color); background-color: #fff; border-radius: 4px; margin-bottom: 8px; }
        .team.winner { font-weight: bold; background-color: var(--accent); }
        .team.tbd { color: var(--text-muted); font-style: italic; }
        .match-connector { position: absolute; left: 100%; top: 50%; width: 20px; height: 2px; background-color: var(--border-color); }
        .round-connector { position: absolute; left: 100%; top: 25%; width: 2px; height: 50%; background-color: var(--border-color); transform: translateY(50%); }
        
        .gemini-commentary {
            background-color: #f0f4f8; /* Light blue-gray background */
            border-left: 4px solid var(--team-blue);
            padding: 1rem;
            border-radius: 0 0.5rem 0.5rem 0;
            font-style: italic;
            color: #334155;
        }
    </style>
</head>
<body class="min-h-screen p-4 sm:p-6 lg:p-8">

    <div class="max-w-7xl mx-auto">
        <header class="text-center mb-10">
            <h1 class="text-3xl sm:text-4xl lg:text-5xl font-bold text-gray-800">Foosball Lab</h1>
            <p class="mt-2 text-base sm:text-lg text-gray-500">Analisi, Strategie e Gloria nel Calcio Balilla</p>
        </header>

        <main class="grid grid-cols-1 lg:grid-cols-3 gap-8">

            <div class="lg:col-span-1 flex flex-col gap-8">
                <div class="card">
                    <h2 class="text-2xl font-semibold mb-4 text-gray-800">Aggiungi Giocatore</h2>
                    <div class="flex gap-2">
                        <input type="text" id="playerNameInput" placeholder="Nome del nuovo giocatore" class="flex-grow">
                        <button id="addPlayerBtn" class="btn btn-primary">Aggiungi</button>
                    </div>
                </div>

                <div class="card">
                    <h2 class="text-2xl font-semibold mb-4 text-gray-800">Registra Partita Amichevole</h2>
                    <div class="space-y-6">
                        <div>
                             <h3 class="font-bold text-gray-600 mb-2 text-lg">Data</h3>
                             <input type="date" id="matchDate">
                        </div>

                        <div>
                            <div class="flex justify-between items-center mb-2">
                                <h3 class="font-bold team-blue-color text-lg">Squadra Blu</h3>
                                <div class="flex items-center gap-2">
                                    <span class="text-sm font-bold team-blue-color" id="teamAEloDisplay">ELO: -</span>
                                    <button id="eloInfoBtnA" title="Spiegazione ELO" class="p-1 rounded-full hover:bg-gray-200">
                                        <svg xmlns="http://www.w3.org/2000/svg" class="h-4 w-4 text-gray-600" fill="none" viewBox="0 0 24 24" stroke="currentColor"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M13 16h-1v-4h-1m1-4h.01M21 12a9 9 0 11-18 0 9 9 0 0118 0z" /></svg>
                                    </button>
                                    <button id="invertRolesABtn" title="Inverti Ruoli" class="p-1 rounded-full hover:bg-gray-200">
                                        <svg class="w-4 h-4 text-gray-600" fill="none" viewBox="0 0 24 24" stroke="currentColor"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M8 7h12m0 0l-4-4m4 4l-4 4m0 6H4m0 0l4 4m-4-4l4-4" /></svg>
                                    </button>
                                </div>
                            </div>
                            <div class="grid grid-cols-1 sm:grid-cols-2 gap-4">
                                <div>
                                    <label class="role-label">‚öîÔ∏è Attacco</label>
                                    <select id="teamAPlayerAttack"></select>
                                </div>
                                <div>
                                    <label class="role-label">üõ°Ô∏è Difesa</label>
                                    <select id="teamAPlayerDefense"></select>
                                </div>
                            </div>
                        </div>

                        <div class="text-center my-2">
                            <button id="invertTeamsBtn" title="Inverti Squadre" class="p-2 rounded-full bg-gray-200 hover:bg-gray-300 transition-transform duration-300 hover:rotate-180">
                                <svg class="w-5 h-5 text-gray-700"  fill="none" viewBox="0 0 24 24" stroke="currentColor"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M7 16V4m0 12l-4-4m4 4l4-4m6 8v-12m0 12l4-4m-4 4l-4-4"/></svg>
                            </button>
                        </div>


                        <div>
                             <div class="flex justify-between items-center mb-2">
                                <h3 class="font-bold team-red-color text-lg">Squadra Rossa</h3>
                                 <div class="flex items-center gap-2">
                                    <span class="text-sm font-bold team-red-color" id="teamBEloDisplay">ELO: -</span>
                                    <button id="eloInfoBtnB" title="Spiegazione ELO" class="p-1 rounded-full hover:bg-gray-200">
                                         <svg xmlns="http://www.w3.org/2000/svg" class="h-4 w-4 text-gray-600" fill="none" viewBox="0 0 24 24" stroke="currentColor"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M13 16h-1v-4h-1m1-4h.01M21 12a9 9 0 11-18 0 9 9 0 0118 0z" /></svg>
                                    </button>
                                    <button id="invertRolesBBtn" title="Inverti Ruoli" class="p-1 rounded-full hover:bg-gray-200">
                                        <svg class="w-4 h-4 text-gray-600" fill="none" viewBox="0 0 24 24" stroke="currentColor"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M8 7h12m0 0l-4-4m4 4l-4 4m0 6H4m0 0l4 4m-4-4l4-4" /></svg>
                                    </button>
                                </div>
                            </div>
                            <div class="grid grid-cols-1 sm:grid-cols-2 gap-4">
                                <div>
                                    <label class="role-label">‚öîÔ∏è Attacco</label>
                                    <select id="teamBPlayerAttack"></select>
                                </div>
                                <div>
                                    <label class="role-label">üõ°Ô∏è Difesa</label>
                                    <select id="teamBPlayerDefense"></select>
                                </div>
                            </div>
                            <button id="teamAssistantBtn" class="btn btn-secondary w-full mt-2 text-sm">Assistente Squadre...</button>
                        </div>
                        
                        <div>
                            <h3 class="font-bold text-gray-600 mb-2 text-lg">Punteggio Finale</h3>
                            <div class="flex items-center gap-4">
                                <div class="flex-1">
                                    <label class="role-label text-center team-blue-color">Blu</label>
                                    <input type="number" id="scoreA" min="0" value="0" class="text-center font-bold text-lg">
                                </div>
                                <span class="pt-5 font-bold text-xl">:</span>
                                 <div class="flex-1">
                                    <label class="role-label text-center team-red-color">Rossa</label>
                                    <input type="number" id="scoreB" min="0" value="0" class="text-center font-bold text-lg">
                                </div>
                            </div>
                        </div>

                        <div>
                            <h3 class="font-bold text-gray-600 mb-2 text-lg">Vincitore</h3>
                            <div class="flex items-center space-x-2 rounded-lg bg-gray-100 p-1">
                                <label class="flex-1 text-center cursor-pointer p-2 rounded-md transition-colors has-[:checked]:bg-[--team-blue] has-[:checked]:text-white has-[:checked]:shadow-md">
                                    <input type="radio" name="winner" value="A" class="sr-only">
                                    <span>Squadra Blu</span>
                                </label>
                                <label class="flex-1 text-center cursor-pointer p-2 rounded-md transition-colors has-[:checked]:bg-[--team-red] has-[:checked]:text-white has-[:checked]:shadow-md">
                                    <input type="radio" name="winner" value="B" class="sr-only">
                                    <span>Squadra Rossa</span>
                                </label>
                            </div>
                        </div>

                        <button id="recordMatchBtn" class="btn btn-primary w-full text-lg">Registra Risultato...</button>
                        
                         <div id="preMatchCommentaryContainer" class="hidden border-t pt-4 mt-4">
                            <h3 class="text-lg font-semibold text-gray-800 mb-2 flex items-center gap-2">
                                <span>üéôÔ∏è</span> Il commento pre-partita
                            </h3>
                            <div id="preMatchCommentaryResult" class="gemini-commentary min-h-[80px] flex items-center justify-center"></div>
                        </div>
                    </div>
                </div>
                 <div id="messageArea" class="hidden p-4 rounded-lg text-center font-semibold text-white"></div>
            </div>

            <div class="lg:col-span-2 flex flex-col gap-8">
                <div class="card">
                    <button class="accordion-header flex justify-between items-center w-full">
                        <h2 class="text-2xl font-semibold text-gray-800">Classifica Giocatori</h2>
                        <svg class="w-6 h-6 shrink-0 transition-transform duration-300" fill="none" viewBox="0 0 24 24" stroke="currentColor"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M19 9l-7 7-7-7"></path></svg>
                    </button>
                    <div id="leaderboard-card" class="accordion-content hidden pt-4">
                        <div class="flex flex-col sm:flex-row items-center gap-4 mb-4 p-2 bg-gray-50 rounded-lg">
                            <div class="flex items-center gap-4">
                                <input type="radio" id="rankOverall" name="rankType" value="overall" class="text-[--team-blue] focus:ring-[--team-blue]" checked><label for="rankOverall" class="text-sm font-medium">Generale</label>
                                <input type="radio" id="rankPeriod" name="rankType" value="period" class="text-[--team-blue] focus:ring-[--team-blue]"><label for="rankPeriod" class="text-sm font-medium">Periodo</label>
                            </div>
                            <div id="leaderboardDateFilters" class="w-full sm:w-auto flex-grow flex flex-col sm:flex-row items-center gap-2 hidden">
                                <input type="date" id="leaderboardStartDate" class="text-sm p-1 w-full">
                                <input type="date" id="leaderboardEndDate" class="text-sm p-1 w-full">
                                <button id="leaderboardFilterBtn" class="btn btn-primary p-2 text-sm w-full sm:w-auto">Filtra</button>
                            </div>
                        </div>
                        
                         <div id="leaderboardCommentaryContainer" class="hidden mb-4">
                            <h3 class="text-lg font-semibold text-gray-800 mb-2 flex items-center gap-2">
                                <span>üéôÔ∏è</span> La parola al critico
                            </h3>
                            <div id="leaderboardCommentaryResult" class="gemini-commentary min-h-[80px] flex items-center justify-center"></div>
                        </div>

                        <div class="flex items-center justify-between p-3 bg-gray-100 rounded-lg font-bold text-gray-600 text-sm mb-2">
                            <div class="flex items-center gap-4">
                                <span class="w-8 text-center">#</span>
                                <button id="nameSortBtn" class="sort-btn flex items-center gap-1 cursor-pointer">
                                    <span>Nome</span>
                                    <svg id="nameSortIcon" class="w-4 h-4" fill="none" viewBox="0 0 24 24" stroke="currentColor"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M19 9l-7 7-7-7" /></svg>
                                </button>
                            </div>
                            <button id="eloSortBtn" class="sort-btn flex items-center gap-1 cursor-pointer">
                                <span>ELO</span>
                                <svg id="eloSortIcon" class="w-4 h-4" fill="none" viewBox="0 0 24 24" stroke="currentColor"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M19 9l-7 7-7-7" /></svg>
                            </button>
                        </div>
                        <p class="text-xs text-gray-500 mb-2">Clicca su un giocatore per l'analisi dettagliata</p>
                        <div id="leaderboard" class="space-y-2"></div>
                    </div>
                </div>

                 <div class="card" id="unrankedPlayersCard">
                    <button class="accordion-header flex justify-between items-center w-full">
                        <h2 class="text-2xl font-semibold text-gray-800">Giocatori non classificati</h2>
                        <svg class="w-6 h-6 shrink-0 transition-transform duration-300" fill="none" viewBox="0 0 24 24" stroke="currentColor"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M19 9l-7 7-7-7"></path></svg>
                    </button>
                    <div class="accordion-content hidden pt-4">
                        <p class="text-sm text-gray-500 -mt-2 mb-4">Questi giocatori non hanno ancora disputato partite.</p>
                        <div id="unrankedPlayers" class="space-y-2"></div>
                    </div>
                </div>

                 <div class="card">
                     <button class="accordion-header flex justify-between items-center w-full">
                        <h2 class="text-2xl font-semibold text-gray-800">Centro Analisi Strategica</h2>
                        <svg class="w-6 h-6 shrink-0 transition-transform duration-300" fill="none" viewBox="0 0 24 24" stroke="currentColor"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M19 9l-7 7-7-7"></path></svg>
                    </button>
                     <div class="accordion-content hidden pt-4">
                         <div class="border-b border-gray-200 mb-4">
                            <nav class="flex space-x-4 -mb-px" aria-label="Tabs">
                                <button data-tab="general" class="comparison-tab modal-tab active">üìà Confronto Generale</button>
                                <button data-tab="roles" class="comparison-tab modal-tab">üõ°Ô∏è Analisi per Ruolo</button>
                                <button data-tab="synergy" class="comparison-tab modal-tab">ü§ù Analisi Sinergie</button>
                            </nav>
                        </div>
                        <div class="space-y-4">
                            <div>
                                <h3 class="font-bold text-gray-600 mb-2">Seleziona Periodo</h3>
                                <div class="grid grid-cols-1 sm:grid-cols-2 gap-4">
                                    <input type="date" id="comparisonStartDate">
                                    <input type="date" id="comparisonEndDate">
                                </div>
                            </div>
                            <div id="synergyControls" class="hidden space-y-2">
                                <h3 class="font-bold text-gray-600">Analizza con...</h3>
                                <select id="synergyPivotPlayer"></select>
                            </div>
                            <div id="rolesControls" class="hidden space-y-2">
                                <h3 class="font-bold text-gray-600">Analizza nel ruolo di...</h3>
                                <select id="rolesSelect">
                                    <option value="attack">‚öîÔ∏è Attacco</option>
                                    <option value="defense">üõ°Ô∏è Difesa</option>
                                </select>
                            </div>

                             <div>
                                 <h3 id="playerListTitle" class="font-bold text-gray-600 mb-2">Seleziona Giocatori</h3>
                                 <div id="comparisonPlayerList" class="grid grid-cols-2 sm:grid-cols-3 gap-2 max-h-40 overflow-y-auto p-2 border rounded-lg border-gray-200"></div>
                             </div>
                             <button id="compareBtn" class="btn btn-primary w-full">Analizza Dati</button>
                         </div>
                    </div>
                </div>
            </div>
        </main>

        <div class="card mt-8 lg:col-span-3">
             <button class="accordion-header flex justify-between items-center w-full">
                <h2 class="text-2xl font-semibold text-gray-800">Storico Partite</h2>
                <svg class="w-6 h-6 shrink-0 transition-transform duration-300" fill="none" viewBox="0 0 24 24" stroke="currentColor"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M19 9l-7 7-7-7"></path></svg>
            </button>
            <div class="accordion-content hidden pt-4">
                <div class="flex justify-between items-center mb-4 gap-2 flex-wrap">
                    <div class="flex items-center gap-2">
                        <input type="date" id="matchHistoryStartDate" class="text-sm p-1 w-auto">
                        <input type="date" id="matchHistoryEndDate" class="text-sm p-1 w-auto">
                        <button id="matchHistoryFilterBtn" class="btn btn-primary p-2 text-sm">Filtra</button>
                        <button id="matchHistoryResetBtn" class="btn p-2 text-sm" style="background-color: var(--text-muted); color: white;">Reset</button>
                    </div>
                    <div class="flex items-center gap-2">
                        <label for="matchSortSelect" class="text-sm font-medium text-gray-700">Ordina per:</label>
                        <select id="matchSortSelect" class="w-auto text-sm rounded-md border-gray-300 shadow-sm" style="padding-right: 2rem;">
                            <option value="date_desc">Data (Pi√π Recente)</option>
                            <option value="date_asc">Data (Meno Recente)</option>
                            <option value="elo_desc">ELO Medio (Alto-Basso)</option>
                            <option value="elo_asc">ELO Medio (Basso-Alto)</option>
                        </select>
                    </div>
                </div>
                <div id="matchHistory" class="space-y-3 max-h-[400px] overflow-y-auto pr-2"></div>
            </div>
        </div>

        <div class="card mt-8 lg:col-span-3">
            <button class="accordion-header flex justify-between items-center w-full">
                <h2 class="text-2xl font-semibold text-gray-800 flex items-center gap-2"><span>üèÜ</span> Gestione Tornei</h2>
                <svg class="w-6 h-6 shrink-0 transition-transform duration-300" fill="none" viewBox="0 0 24 24" stroke="currentColor"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M19 9l-7 7-7-7"></path></svg>
            </button>
            <div class="accordion-content hidden pt-4">
                <button id="createNewTournamentBtn" class="btn btn-primary w-full mb-6">üèÜ Crea Nuovo Torneo</button>
                <div class="grid grid-cols-1 md:grid-cols-2 gap-8">
                    <div>
                        <h3 class="text-xl font-bold text-gray-700 mb-4 border-b pb-2">In Corso</h3>
                        <div id="inProgressTournaments" class="space-y-4"></div>
                    </div>
                    <div>
                        <h3 class="text-xl font-bold text-gray-700 mb-4 border-b pb-2">Completati</h3>
                        <div id="completedTournaments" class="space-y-4"></div>
                    </div>
                </div>
            </div>
        </div>

        <div class="card mt-8 lg:col-span-3">
            <button class="accordion-header flex justify-between items-center w-full">
                <h2 class="text-2xl font-semibold text-gray-800">Gestione Dati</h2>
                <svg class="w-6 h-6 shrink-0 transition-transform duration-300" fill="none" viewBox="0 0 24 24" stroke="currentColor"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M19 9l-7 7-7-7"></path></svg>
            </button>
            <div class="accordion-content hidden pt-4">
                <div class="space-y-4">
                    <button id="linkFileBtn" class="btn w-full" style="background-color: var(--team-blue); color: white;">Collega/Crea dati.json</button>
                     <p class="text-xs text-center text-gray-500">Salva i dati in un file locale per la massima persistenza e condivisione.</p>
                         <div class="border-t pt-4 mt-4">
                            <h3 class="font-semibold text-gray-700 mb-2 text-lg">Gemini AI API Key</h3>
                            <input type="password" id="geminiApiKeyInput" placeholder="Inserisci la tua API Key di Gemini">
                             <p class="text-xs text-center text-gray-500 mt-2">La chiave √® salvata solo nel tuo browser e non viene condivisa.</p>
                         </div>
                     <div class="border-t pt-4 mt-4">
                         <h3 class="font-semibold text-gray-700 mb-2 text-lg">Backup / Ripristino</h3>
                        <button id="exportBtn" class="btn w-full" style="background-color: var(--text-muted); color: white;">Esporta Backup (JSON)</button>
                        <button id="importBtn" class="btn w-full mt-2" style="background-color: var(--text-muted); color: white;">Importa Backup (JSON)</button>
                        <input type="file" id="importFileInput" accept=".json" class="hidden">
                     </div>
                    <div class="border-t pt-4 mt-4">
                         <h3 class="font-semibold text-gray-700 mb-2 text-lg">Eliminazione Multipla</h3>
                         <div class="grid grid-cols-1 sm:grid-cols-2 gap-2">
                             <input type="date" id="bulkDeleteStartDate" title="Data di inizio per eliminazione">
                             <input type="date" id="bulkDeleteEndDate" title="Data di fine per eliminazione">
                         </div>
                         <button id="bulkDeleteBtn" class="btn btn-danger w-full mt-2">Elimina Partite nel Periodo...</button>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <!-- Floating Chat Button -->
    <button id="geminiChatFab" class="fixed bottom-6 right-6 bg-[--team-blue] text-white w-16 h-16 rounded-full shadow-lg flex items-center justify-center text-3xl hover:bg-[--team-blue-dark] transition-transform hover:scale-110 z-40">
        <svg xmlns="http://www.w3.org/2000/svg" class="h-8 w-8" viewBox="0 0 24 24" fill="currentColor"><path d="M16.81,5.85a5.3,5.3,0,0,0-7.62,0,5.46,5.46,0,0,0,0,7.62L12,16.29l2.81-2.82A5.4,5.4,0,0,0,16.81,5.85ZM15,10.5,12,13.4l-3-2.91a3.59,3.59,0,0,1,0-5,3.53,3.53,0,0,1,5,0,3.64,3.64,0,0,1,1,2.5,3.53,3.53,0,0,1-1,2.51Z"/><path d="M19.93,12.2a2.83,2.83,0,0,0,0-4.24,2.78,2.78,0,0,0-4,0l-1,1,4.06,4,1-1.05A2.9,2.9,0,0,0,19.93,12.2Z"/><path d="M12.2,19.93a2.83,2.83,0,0,0,4.24,0,2.78,2.78,0,0,0,0-4l-1,1-4.06,4,1.05,1Z"/><path d="M4.07,12.2a2.83,2.83,0,0,0,0-4.24,2.78,2.78,0,0,0-4,0l0,0,0,0a2.78,2.78,0,0,0,0,4l4.05,4,1-1Z"/><path d="M7.79,16.29a2.83,2.83,0,0,0,4.24,0,2.78,2.78,0,0,0,0-4l-1-1-4.05,4,1,1Z"/></svg>
    </button>

    <!-- Chat Modal -->
    <div id="geminiChatModal" class="fixed inset-0 bg-black bg-opacity-70 flex items-center justify-center p-4 hidden z-50">
        <div class="card w-full max-w-2xl h-[80vh] flex flex-col">
            <div class="flex justify-between items-center mb-4 flex-shrink-0">
                <h2 class="text-2xl font-semibold text-gray-800 flex items-center gap-3">
                    <svg xmlns="http://www.w3.org/2000/svg" class="h-7 w-7 text-[--team-blue]" viewBox="0 0 24 24" fill="currentColor"><path d="M16.81,5.85a5.3,5.3,0,0,0-7.62,0,5.46,5.46,0,0,0,0,7.62L12,16.29l2.81-2.82A5.4,5.4,0,0,0,16.81,5.85ZM15,10.5,12,13.4l-3-2.91a3.59,3.59,0,0,1,0-5,3.53,3.53,0,0,1,5,0,3.64,3.64,0,0,1,1,2.5,3.53,3.53,0,0,1-1,2.51Z"/><path d="M19.93,12.2a2.83,2.83,0,0,0,0-4.24,2.78,2.78,0,0,0-4,0l-1,1,4.06,4,1-1.05A2.9,2.9,0,0,0,19.93,12.2Z"/><path d="M12.2,19.93a2.83,2.83,0,0,0,4.24,0,2.78,2.78,0,0,0,0-4l-1,1-4.06,4,1.05,1Z"/><path d="M4.07,12.2a2.83,2.83,0,0,0,0-4.24,2.78,2.78,0,0,0-4,0l0,0,0,0a2.78,2.78,0,0,0,0,4l4.05,4,1-1Z"/><path d="M7.79,16.29a2.83,2.83,0,0,0,4.24,0,2.78,2.78,0,0,0,0-4l-1-1-4.05,4,1,1Z"/></svg>
                    <span>Chatta con l'Assistente Dati</span>
                </h2>
                <button id="closeGeminiChatModal" class="text-gray-500 text-3xl font-bold hover:text-gray-800">&times;</button>
            </div>
            <div id="geminiChatMessages" class="flex-grow overflow-y-auto p-4 bg-gray-50 rounded-lg mb-4 space-y-4">
                <!-- Messages will be injected here -->
            </div>
            <div class="flex gap-2 flex-shrink-0">
                <input type="text" id="geminiChatInput" placeholder="Es: 'Chi √® il giocatore con pi√π partite giocate?'" class="flex-grow">
                <button id="geminiChatSendBtn" class="btn btn-primary">Invia</button>
            </div>
        </div>
    </div>

    <div id="preMatchAssistantModal" class="fixed inset-0 bg-black bg-opacity-70 flex items-center justify-center p-4 z-50">
        <div class="card w-full max-w-xl transform transition-all text-center relative">
            <button id="closePreMatchAssistantBtn" class="absolute top-2 right-4 text-gray-500 text-3xl font-bold hover:text-gray-800">&times;</button>
            <h2 class="text-2xl font-bold text-gray-800 mb-2">Benvenuto al Foosball Lab!</h2>
            <p class="text-gray-600 mb-6">Cosa vuoi fare oggi?</p>
            <div id="wizardActions" class="space-y-4">
                </div>
            <div class="mt-6 text-sm">
                <label class="flex items-center justify-center gap-2">
                    <input type="checkbox" id="hideWizardCheckbox" class="rounded border-gray-300 text-[--team-blue] focus:ring-[--team-blue]">
                    <span>Non mostrare pi√π all'avvio</span>
                </label>
            </div>
        </div>
    </div>

    <div id="historyModal" class="fixed inset-0 bg-black bg-opacity-70 flex items-center justify-center p-4 hidden z-50">
        <div class="card w-full max-w-4xl transform transition-all flex flex-col max-h-[90vh]">
            <div class="flex justify-between items-center mb-2 flex-shrink-0">
                <div id="playerProfileHeader"></div>
                <button id="closeHistoryModal" class="text-gray-500 text-3xl font-bold hover:text-gray-800">&times;</button>
            </div>
             <div class="grid grid-cols-1 sm:grid-cols-3 gap-4 mb-4 pb-4 border-b border-gray-200 items-end flex-shrink-0">
                <div>
                    <label class="block text-sm font-medium text-gray-700">Data Inizio</label>
                    <input type="date" id="historyStartDate" class="mt-1">
                </div>
                 <div>
                    <label class="block text-sm font-medium text-gray-700">Data Fine</label>
                    <input type="date" id="historyEndDate" class="mt-1">
                </div>
                <button id="historyFilterBtn" class="btn btn-primary h-fit">Applica Filtro</button>
            </div>

            <div class="overflow-y-auto flex-grow pr-2">
                <div class="mb-6">
                    <h3 class="text-xl font-semibold text-gray-800 mb-2 flex items-center gap-2">
                        <span>ü§ñ</span> Coach AI
                    </h3>
                    <div id="geminiAnalysisContainer" class="gemini-commentary min-h-[100px] flex flex-col justify-center items-center">
                        <div id="geminiAnalysisResult" class="text-gray-700 w-full"></div>
                        <p id="geminiLoading" class="hidden text-sm text-gray-500 animate-pulse mt-2">Il coach sta analizzando i dati...</p>
                    </div>
                </div>

                <div class="border-b border-gray-200 mb-4 flex-shrink-0">
                    <nav class="flex space-x-2 -mb-px overflow-x-auto" aria-label="Tabs">
                        <button id="tabStats" class="modal-tab">üìä Statistiche & Sinergie</button>
                        <button id="tabChart" class="modal-tab active">üìà Andamento Grafico</button>
                        <button id="tabHistory" class="modal-tab">üìú Storico Partite</button>
                        <button id="tabTournaments" class="modal-tab">üèÜ Tornei</button>
                    </nav>
                </div>

                <div id="tabStatsContent" class="hidden">
                     <div class="grid grid-cols-2 md:grid-cols-3 gap-4 mb-6 text-center">
                        <div class="p-4 bg-gray-50 rounded-lg"><p class="text-2xl font-bold text-gray-800" id="statsMatchesPlayed">-</p><p class="text-sm text-gray-600">Partite Giocate</p></div>
                        <div class="p-4 bg-gray-50 rounded-lg"><p class="text-2xl font-bold text-green-600" id="statsWinRate">-</p><p class="text-sm text-gray-600">Vittorie</p></div>
                        <div class="p-4 bg-gray-50 rounded-lg"><p class="text-2xl font-bold text-gray-800" id="statsEloChange">-</p><p class="text-sm text-gray-600">Variazione ELO</p></div>
                        <div class="p-4 bg-blue-50 rounded-lg"><p class="text-2xl font-bold text-blue-800" id="statsBlueWinRate">-</p><p class="text-sm text-gray-600">Vittorie Squadra Blu</p></div>
                        <div class="p-4 bg-red-50 rounded-lg"><p class="text-2xl font-bold text-red-800" id="statsRedWinRate">-</p><p class="text-sm text-gray-600">Vittorie Squadra Rossa</p></div>
                        <div class="p-4 bg-yellow-100 rounded-lg border-2 border-yellow-300"><p class="text-2xl font-bold text-yellow-900 truncate" id="statsBestRole">-</p><p class="text-sm text-yellow-800">Ruolo Migliore</p></div>
                     </div>
                     <div id="bestSynergyHighlight" class="mb-6"></div>
                     <h3 class="text-xl font-semibold text-gray-800 mb-3">Sinergie Compagni (Dettaglio)</h3>
                     <div id="bestTeammatesContainer" class="space-y-3"></div>
                </div>
                <div id="tabChartContent">
                    <div class="bg-gray-50 p-4 rounded-lg"><canvas id="eloHistoryChart"></canvas></div>
                </div>
                <div id="tabHistoryContent" class="hidden">
                     <div class="flex justify-end items-center mb-4 gap-2">
                        <label for="playerMatchSortSelect" class="text-sm font-medium text-gray-700">Ordina per:</label>
                        <select id="playerMatchSortSelect" class="w-auto text-sm rounded-md border-gray-300 shadow-sm"><option value="date_desc">Data (Pi√π Recente)</option><option value="date_asc">Data (Meno Recente)</option></select>
                    </div>
                    <div id="playerMatchHistoryContainer" class="space-y-2"></div>
                </div>
                 <div id="tabTournamentsContent" class="hidden">
                    <div id="playerTournamentsContainer" class="space-y-4"></div>
                </div>
            </div>
        </div>
    </div>

    <div id="comparisonModal" class="fixed inset-0 bg-black bg-opacity-70 flex items-center justify-center p-4 hidden z-50">
        <div class="card w-full max-w-4xl transform transition-all">
             <div class="flex justify-between items-center mb-4">
                <h2 id="comparisonModalTitle" class="text-2xl font-semibold text-gray-800"></h2>
                 <div class="flex items-center gap-2">
                    <button id="closeComparisonModal" class="text-gray-500 text-3xl font-bold hover:text-gray-800">&times;</button>
                </div>
            </div>
            <div id="comparisonModalContent" class="bg-gray-50 p-4 rounded-lg max-h-[70vh] overflow-y-auto"></div>
        </div>
    </div>

    <div id="teamAssistantModal" class="fixed inset-0 bg-black bg-opacity-70 flex items-center justify-center p-4 hidden z-50">
        <div class="card w-full max-w-2xl transform transition-all">
             <div class="flex justify-between items-center mb-4">
                <h2 class="text-2xl font-semibold text-gray-800">Assistente Squadre</h2>
                <button id="closeTeamAssistantModal" class="text-gray-500 text-3xl font-bold hover:text-gray-800">&times;</button>
            </div>
            <div class="border-b border-gray-200 mb-4">
                <nav class="flex space-x-4 -mb-px" aria-label="Tabs">
                    <button data-tab="opponents" class="assistant-tab modal-tab active">Trova Avversari</button>
                    <button data-tab="partners" class="assistant-tab modal-tab">Trova Compagno</button>
                </nav>
            </div>

            <div id="assistantOpponentsContent">
                 <div id="opponentPairsList" class="space-y-4 max-h-[60vh] overflow-y-auto p-1"></div>
            </div>
            <div id="assistantPartnersContent" class="hidden space-y-4">
                <div>
                    <h3 class="font-bold text-gray-600 mb-2">Seleziona un giocatore e il suo ruolo</h3>
                    <div class="grid grid-cols-1 sm:grid-cols-2 gap-4 mb-4">
                        <select id="partnerFinderPlayer"></select>
                        <select id="partnerFinderRole">
                            <option value="attack">‚öîÔ∏è Attacco</option>
                            <option value="defense">üõ°Ô∏è Difesa</option>
                        </select>
                    </div>
                    <div class="grid grid-cols-1 sm:grid-cols-2 gap-4">
                         <input type="date" id="partnerFinderStartDate">
                         <input type="date" id="partnerFinderEndDate">
                    </div>
                </div>
                <div id="partnerList" class="space-y-2 max-h-[40vh] overflow-y-auto p-1"></div>
            </div>
        </div>
    </div>
    
    <div id="eloExplanationModal" class="fixed inset-0 bg-black bg-opacity-70 flex items-center justify-center p-4 hidden z-50">
        <div class="card w-full max-w-2xl transform transition-all">
             <div class="flex justify-between items-center mb-4">
                <h2 class="text-2xl font-semibold text-gray-800">Calcolo ELO basato sul Ruolo</h2>
                <button id="closeEloExplanationModal" class="text-gray-500 text-3xl font-bold hover:text-gray-800">&times;</button>
            </div>
            <div id="eloExplanationContent" class="space-y-4 text-gray-700 max-h-[60vh] overflow-y-auto">
                 <p class="animate-pulse">Sto chiedendo a Gemini di spiegare il calcolo...</p>
            </div>
        </div>
    </div>

    <div id="confirmRecordModal" class="fixed inset-0 bg-black bg-opacity-70 flex items-center justify-center p-4 hidden z-50">
        <div class="card w-full max-w-md transform transition-all text-center">
             <h2 class="text-2xl font-bold text-gray-800 mb-4">Conferma Partita</h2>
             <div id="recordSummary" class="text-left space-y-2 mb-6"></div>
             <div class="flex justify-center gap-4">
                 <button id="cancelRecordBtn" class="btn" style="background-color: var(--text-muted); color: white;">Annulla</button>
                 <button id="confirmRecordBtn" class="btn btn-primary">Conferma Partita</button>
             </div>
        </div>
    </div>

    <div id="confirmDeleteModal" class="fixed inset-0 bg-black bg-opacity-70 flex items-center justify-center p-4 hidden z-50">
        <div class="card w-full max-w-md transform transition-all text-center">
             <h2 class="text-2xl font-bold text-gray-800 mb-4">Conferma Eliminazione</h2>
             <p class="text-gray-600 mb-6">Sei sicuro di voler eliminare questa partita? L'azione √® irreversibile.</p>
             <div class="flex justify-center gap-4">
                 <button id="cancelDeleteBtn" class="btn" style="background-color: var(--text-muted); color: white;">Annulla</button>
                 <button id="confirmDeleteBtn" class="btn btn-danger">Conferma Eliminazione</button>
             </div>
        </div>
    </div>

    <div id="confirmPlayerDeleteModal" class="fixed inset-0 bg-black bg-opacity-70 flex items-center justify-center p-4 hidden z-50">
        <div class="card w-full max-w-md transform transition-all text-center">
             <h2 class="text-2xl font-bold text-gray-800 mb-4">Conferma Eliminazione Giocatore</h2>
             <p id="playerDeleteSummaryText" class="text-gray-600 mb-6">Sei sicuro di voler eliminare questo giocatore? L'azione √® irreversibile.</p>
             <div class="flex justify-center gap-4">
                 <button id="cancelPlayerDeleteBtn" class="btn" style="background-color: var(--text-muted); color: white;">Annulla</button>
                 <button id="confirmPlayerDeleteBtn" class="btn btn-danger">Conferma Eliminazione</button>
             </div>
        </div>
    </div>

    <div id="confirmDeleteTournamentModal" class="fixed inset-0 bg-black bg-opacity-70 flex items-center justify-center p-4 hidden z-50">
        <div class="card w-full max-w-md transform transition-all text-center">
             <h2 class="text-2xl font-bold text-gray-800 mb-4">Conferma Eliminazione Torneo</h2>
             <p id="tournamentDeleteSummaryText" class="text-gray-600 mb-6"></p>
             <div class="flex justify-center gap-4">
                 <button id="cancelTournamentDeleteBtn" class="btn" style="background-color: var(--text-muted); color: white;">Annulla</button>
                 <button id="confirmTournamentDeleteBtn" class="btn btn-danger">Conferma Eliminazione</button>
             </div>
        </div>
    </div>

    <div id="confirmBulkDeleteModal" class="fixed inset-0 bg-black bg-opacity-70 flex items-center justify-center p-4 hidden z-50">
        <div class="card w-full max-w-2xl transform transition-all">
             <h2 class="text-2xl font-bold text-gray-800 mb-2">Conferma Eliminazione Multipla</h2>
             <p id="bulkDeleteSummaryText" class="text-gray-600 mb-4"></p>
             <div id="bulkDeleteMatchList" class="space-y-2 max-h-60 overflow-y-auto p-2 border rounded-lg bg-gray-50 mb-6"></div>
             <div class="flex justify-end gap-4">
                 <button id="cancelBulkDeleteBtn" class="btn" style="background-color: var(--text-muted); color: white;">Annulla</button>
                 <button id="confirmBulkDeleteBtn" class="btn btn-danger">Conferma Eliminazione</button>
             </div>
        </div>
    </div>

    <div id="tournamentCreationModal" class="fixed inset-0 bg-black bg-opacity-70 flex items-center justify-center p-4 hidden z-50">
        <div class="card w-full max-w-2xl transform transition-all flex flex-col max-h-[90vh]">
            <div class="flex justify-between items-center mb-4 flex-shrink-0">
                <h2 class="text-2xl font-bold text-gray-800">Crea Nuovo Torneo</h2>
                <button id="closeTournamentCreationModal" class="text-gray-500 text-3xl font-bold hover:text-gray-800">&times;</button>
            </div>
            <div class="overflow-y-auto flex-grow">
                <div id="tourneyStep1">
                    <div class="space-y-4">
                        <div>
                            <label class="font-bold text-gray-600">Nome Torneo</label>
                            <input type="text" id="tournamentNameInput" placeholder="Es. Torneo Estivo 2025">
                        </div>
                        <div class="grid grid-cols-2 gap-4">
                             <div>
                                <label class="font-bold text-gray-600">Numero Squadre</label>
                                <select id="tournamentTeamsNumber">
                                    <option value="4">4 squadre (8 giocatori)</option>
                                    <option value="8" selected>8 squadre (16 giocatori)</option>
                                    <option value="16">16 squadre (32 giocatori)</option>
                                </select>
                            </div>
                            <div>
                                <label class="font-bold text-gray-600">Data Inizio</label>
                                <input type="date" id="tournamentDateInput">
                            </div>
                        </div>
                        <div class="p-3 bg-yellow-50 border border-yellow-200 rounded-lg">
                             <label class="flex items-center gap-3 cursor-pointer">
                                <input type="checkbox" id="tournamentAffectsElo" class="rounded border-gray-300 text-[--team-blue] focus:ring-[--team-blue] h-5 w-5">
                                <span class="font-semibold text-yellow-900">Le partite di questo torneo influenzeranno la classifica ELO.</span>
                            </label>
                        </div>
                    </div>
                     <button id="tourneyNextToStep2" class="btn btn-primary w-full mt-6">Prossimo: Seleziona Giocatori</button>
                </div>
                <div id="tourneyStep2" class="hidden">
                    <h3 class="font-bold text-lg mb-2">Seleziona Giocatori Partecipanti</h3>
                    <p class="text-sm text-gray-500 mb-4">Devi selezionare <span id="requiredPlayerCount" class="font-bold"></span> giocatori.</p>
                    <div id="tournamentPlayerSelection" class="grid grid-cols-2 sm:grid-cols-3 gap-2 max-h-60 overflow-y-auto p-2 border rounded-lg"></div>
                    <div class="flex justify-between mt-6 gap-4">
                         <button id="tourneyBackToStep1" class="btn" style="background-color: var(--text-muted); color:white;">Indietro</button>
                         <button id="tourneyNextToStep3" class="btn btn-primary flex-grow" disabled>Prossimo: Crea Squadre</button>
                    </div>
                </div>
                <div id="tourneyStep3" class="hidden">
                     <div class="border-b border-gray-200 mb-4">
                        <nav class="flex space-x-4 -mb-px" aria-label="Tabs">
                            <button data-tab="balanced" class="assistant-tab modal-tab active">Crea Squadre Bilanciate</button>
                            <button data-tab="manual" class="assistant-tab modal-tab">Crea Squadre Manualmente</button>
                        </nav>
                    </div>
                    <div id="tourneyBalancedTeams" class="space-y-3 max-h-60 overflow-y-auto pr-2"></div>
                    <div id="tourneyManualTeams" class="hidden space-y-3 max-h-60 overflow-y-auto pr-2"></div>

                     <div class="flex justify-between mt-6 gap-4">
                         <button id="tourneyBackToStep2" class="btn" style="background-color: var(--text-muted); color:white;">Indietro</button>
                         <button id="createTournamentBtn" class="btn btn-primary flex-grow">Crea Torneo</button>
                    </div>
                </div>
            </div>
        </div>
    </div>

     <div id="tournamentViewModal" class="fixed inset-0 bg-black bg-opacity-70 flex items-center justify-center p-4 hidden z-50">
        <div class="card w-full max-w-6xl transform transition-all flex flex-col max-h-[90vh]">
            <div id="tournamentViewHeader" class="flex justify-between items-start mb-4 flex-shrink-0"></div>
            <div id="tournamentBracketContainer" class="overflow-x-auto flex-grow bg-gray-50 p-4 rounded-lg"></div>
        </div>
    </div>

    <div id="tournamentMatchModal" class="fixed inset-0 bg-black bg-opacity-70 flex items-center justify-center p-4 hidden z-50">
        <div class="card w-full max-w-2xl transform transition-all">
             <h2 class="text-2xl font-bold text-gray-800 mb-4">Gestisci Partita Torneo</h2>
             <div id="tournamentMatchContent" class="space-y-6">
                </div>
             <div class="flex justify-end gap-4 mt-6">
                 <button id="cancelTournamentMatch" class="btn" style="background-color: var(--text-muted); color: white;">Annulla</button>
                 <button id="confirmTournamentMatch" class="btn btn-primary">Conferma Risultato</button>
             </div>
        </div>
    </div>

    <script>
        document.addEventListener('DOMContentLoaded', () => {
            // --- Elementi del DOM ---
            const playerNameInput = document.getElementById('playerNameInput');
            const addPlayerBtn = document.getElementById('addPlayerBtn');
            const recordMatchBtn = document.getElementById('recordMatchBtn');
            const leaderboard = document.getElementById('leaderboard');
            const unrankedPlayersContainer = document.getElementById('unrankedPlayers');
            const unrankedPlayersCard = document.getElementById('unrankedPlayersCard');
            const messageArea = document.getElementById('messageArea');
            const matchDateInput = document.getElementById('matchDate');
            const scoreAInput = document.getElementById('scoreA');
            const scoreBInput = document.getElementById('scoreB');
            const winnerRadios = document.querySelectorAll('input[name="winner"]');
            const matchHistoryContainer = document.getElementById('matchHistory');
            const exportBtn = document.getElementById('exportBtn');
            const importBtn = document.getElementById('importBtn');
            const importFileInput = document.getElementById('importFileInput');
            const linkFileBtn = document.getElementById('linkFileBtn');
            const body = document.body;

            const teamASelects = { attack: document.getElementById('teamAPlayerAttack'), defense: document.getElementById('teamAPlayerDefense') };
            const teamBSelects = { attack: document.getElementById('teamBPlayerAttack'), defense: document.getElementById('teamBPlayerDefense') };
            const allSelects = [...Object.values(teamASelects), ...Object.values(teamBSelects)];

            const teamAEloDisplay = document.getElementById('teamAEloDisplay');
            const teamBEloDisplay = document.getElementById('teamBEloDisplay');
            const eloInfoBtnA = document.getElementById('eloInfoBtnA');
            const eloInfoBtnB = document.getElementById('eloInfoBtnB');
            const eloExplanationModal = document.getElementById('eloExplanationModal');
            const eloExplanationContent = document.getElementById('eloExplanationContent');
            const teamAssistantBtn = document.getElementById('teamAssistantBtn');
            const invertRolesABtn = document.getElementById('invertRolesABtn');
            const invertRolesBBtn = document.getElementById('invertRolesBBtn');
            const invertTeamsBtn = document.getElementById('invertTeamsBtn');

            // Leaderboard Sorting & AI
            const nameSortBtn = document.getElementById('nameSortBtn');
            const nameSortIcon = document.getElementById('nameSortIcon');
            const eloSortBtn = document.getElementById('eloSortBtn');
            const eloSortIcon = document.getElementById('eloSortIcon');
            const leaderboardDateFilters = document.getElementById('leaderboardDateFilters');
            const leaderboardStartDate = document.getElementById('leaderboardStartDate');
            const leaderboardEndDate = document.getElementById('leaderboardEndDate');
            const leaderboardFilterBtn = document.getElementById('leaderboardFilterBtn');
            const rankTypeRadios = document.querySelectorAll('input[name="rankType"]');
            const leaderboardCommentaryContainer = document.getElementById('leaderboardCommentaryContainer');
            const leaderboardCommentaryResult = document.getElementById('leaderboardCommentaryResult');


            // Match History
            const matchSortSelect = document.getElementById('matchSortSelect');
            const matchHistoryStartDate = document.getElementById('matchHistoryStartDate');
            const matchHistoryEndDate = document.getElementById('matchHistoryEndDate');
            const matchHistoryFilterBtn = document.getElementById('matchHistoryFilterBtn');
            const matchHistoryResetBtn = document.getElementById('matchHistoryResetBtn');


            // Modal Storico Individuale
            const historyModal = document.getElementById('historyModal');
            const playerProfileHeader = document.getElementById('playerProfileHeader');
            const closeHistoryModalBtn = document.getElementById('closeHistoryModal');
            const historyStartDateInput = document.getElementById('historyStartDate');
            const historyEndDateInput = document.getElementById('historyEndDate');
            const historyFilterBtn = document.getElementById('historyFilterBtn');
            const playerAnalysisTabs = {
                stats: document.getElementById('tabStats'),
                chart: document.getElementById('tabChart'),
                history: document.getElementById('tabHistory'),
                tournaments: document.getElementById('tabTournaments'),
            };
            const playerAnalysisContents = {
                stats: document.getElementById('tabStatsContent'),
                chart: document.getElementById('tabChartContent'),
                history: document.getElementById('tabHistoryContent'),
                tournaments: document.getElementById('tabTournamentsContent'),
            };
            const playerMatchHistoryContainer = document.getElementById('playerMatchHistoryContainer');
            const playerTournamentsContainer = document.getElementById('playerTournamentsContainer');
            const playerMatchSortSelect = document.getElementById('playerMatchSortSelect');
            const statsMatchesPlayed = document.getElementById('statsMatchesPlayed');
            const statsWinRate = document.getElementById('statsWinRate');
            const statsEloChange = document.getElementById('statsEloChange');
            const statsBestRole = document.getElementById('statsBestRole');
            const statsBlueWinRate = document.getElementById('statsBlueWinRate');
            const statsRedWinRate = document.getElementById('statsRedWinRate');
            const bestSynergyHighlight = document.getElementById('bestSynergyHighlight');
            const bestTeammatesContainer = document.getElementById('bestTeammatesContainer');

            // Sezione Analisi Strategica
            const comparisonTabs = document.querySelectorAll('.comparison-tab');
            const comparisonPlayerList = document.getElementById('comparisonPlayerList');
            const playerListTitle = document.getElementById('playerListTitle');
            const synergyControls = document.getElementById('synergyControls');
            const synergyPivotPlayer = document.getElementById('synergyPivotPlayer');
            const rolesControls = document.getElementById('rolesControls');
            const rolesSelect = document.getElementById('rolesSelect');
            const comparisonStartDateInput = document.getElementById('comparisonStartDate');
            const comparisonEndDateInput = document.getElementById('comparisonEndDate');
            const compareBtn = document.getElementById('compareBtn');

            // Modal Analisi
            const comparisonModal = document.getElementById('comparisonModal');
            const comparisonModalTitle = document.getElementById('comparisonModalTitle');
            const comparisonModalContent = document.getElementById('comparisonModalContent');
            const closeComparisonModalBtn = document.getElementById('closeComparisonModal');

            // Modal Assistente Squadre
            const teamAssistantModal = document.getElementById('teamAssistantModal');
            const closeTeamAssistantModal = document.getElementById('closeTeamAssistantModal');
            const assistantTabs = document.querySelectorAll('.assistant-tab');
            const assistantOpponentsContent = document.getElementById('assistantOpponentsContent');
            const assistantPartnersContent = document.getElementById('assistantPartnersContent');
            const opponentPairsList = document.getElementById('opponentPairsList');
            const partnerFinderPlayer = document.getElementById('partnerFinderPlayer');
            const partnerFinderRole = document.getElementById('partnerFinderRole');
            const partnerFinderStartDate = document.getElementById('partnerFinderStartDate');
            const partnerFinderEndDate = document.getElementById('partnerFinderEndDate');
            const partnerList = document.getElementById('partnerList');

            // Modal Pre-Partita
            const preMatchAssistantModal = document.getElementById('preMatchAssistantModal');
            const wizardActions = document.getElementById('wizardActions');
            const hideWizardCheckbox = document.getElementById('hideWizardCheckbox');
            const preMatchCommentaryContainer = document.getElementById('preMatchCommentaryContainer');
            const preMatchCommentaryResult = document.getElementById('preMatchCommentaryResult');

            // Sezione Tornei
            const createNewTournamentBtn = document.getElementById('createNewTournamentBtn');
            const inProgressTournaments = document.getElementById('inProgressTournaments');
            const completedTournaments = document.getElementById('completedTournaments');
            const tournamentCreationModal = document.getElementById('tournamentCreationModal');
            const closeTournamentCreationModal = document.getElementById('closeTournamentCreationModal');
            const tournamentNameInput = document.getElementById('tournamentNameInput');
            const tournamentTeamsNumber = document.getElementById('tournamentTeamsNumber');
            const tournamentDateInput = document.getElementById('tournamentDateInput');
            const tournamentAffectsElo = document.getElementById('tournamentAffectsElo');
            const tournamentPlayerSelection = document.getElementById('tournamentPlayerSelection');
            const tourneyStep1 = document.getElementById('tourneyStep1');
            const tourneyStep2 = document.getElementById('tourneyStep2');
            const tourneyStep3 = document.getElementById('tourneyStep3');
            const tourneyNextToStep2 = document.getElementById('tourneyNextToStep2');
            const tourneyBackToStep1 = document.getElementById('tourneyBackToStep1');
            const tourneyNextToStep3 = document.getElementById('tourneyNextToStep3');
            const tourneyBackToStep2 = document.getElementById('tourneyBackToStep2');
            const tourneyBalancedTeams = document.getElementById('tourneyBalancedTeams');
            const tourneyManualTeams = document.getElementById('tourneyManualTeams');
            const createTournamentBtn = document.getElementById('createTournamentBtn');
            const tournamentViewModal = document.getElementById('tournamentViewModal');
            const tournamentViewHeader = document.getElementById('tournamentViewHeader');
            const tournamentBracketContainer = document.getElementById('tournamentBracketContainer');
            const tournamentMatchModal = document.getElementById('tournamentMatchModal');
            const tournamentMatchContent = document.getElementById('tournamentMatchContent');
            const cancelTournamentMatch = document.getElementById('cancelTournamentMatch');
            const confirmTournamentMatch = document.getElementById('confirmTournamentMatch');
            const confirmDeleteTournamentModal = document.getElementById('confirmDeleteTournamentModal');
            const tournamentDeleteSummaryText = document.getElementById('tournamentDeleteSummaryText');
            const cancelTournamentDeleteBtn = document.getElementById('cancelTournamentDeleteBtn');
            const confirmTournamentDeleteBtn = document.getElementById('confirmTournamentDeleteBtn');


            // Altri Modals
            const confirmRecordModal = document.getElementById('confirmRecordModal');
            const recordSummary = document.getElementById('recordSummary');
            const cancelRecordBtn = document.getElementById('cancelRecordBtn');
            const confirmRecordBtn = document.getElementById('confirmRecordBtn');
            const confirmDeleteModal = document.getElementById('confirmDeleteModal');
            const cancelDeleteBtn = document.getElementById('cancelDeleteBtn');
            const confirmDeleteBtn = document.getElementById('confirmDeleteBtn');
            const confirmPlayerDeleteModal = document.getElementById('confirmPlayerDeleteModal');
            const cancelPlayerDeleteBtn = document.getElementById('cancelPlayerDeleteBtn');
            const confirmPlayerDeleteBtn = document.getElementById('confirmPlayerDeleteBtn');
            const bulkDeleteStartDateInput = document.getElementById('bulkDeleteStartDate');
            const bulkDeleteEndDateInput = document.getElementById('bulkDeleteEndDate');
            const bulkDeleteBtn = document.getElementById('bulkDeleteBtn');
            const confirmBulkDeleteModal = document.getElementById('confirmBulkDeleteModal');
            const bulkDeleteSummaryText = document.getElementById('bulkDeleteSummaryText');
            const bulkDeleteMatchList = document.getElementById('bulkDeleteMatchList');
            const cancelBulkDeleteBtn = document.getElementById('cancelBulkDeleteBtn');
            const confirmBulkDeleteBtn = document.getElementById('confirmBulkDeleteBtn');

            // Gemini AI Elements
            const geminiApiKeyInput = document.getElementById('geminiApiKeyInput');
            const geminiAnalysisContainer = document.getElementById('geminiAnalysisContainer');
            const geminiAnalysisResult = document.getElementById('geminiAnalysisResult');
            const geminiLoading = document.getElementById('geminiLoading');
            const geminiChatFab = document.getElementById('geminiChatFab');
            const geminiChatModal = document.getElementById('geminiChatModal');
            const closeGeminiChatModal = document.getElementById('closeGeminiChatModal');
            const geminiChatMessages = document.getElementById('geminiChatMessages');
            const geminiChatInput = document.getElementById('geminiChatInput');
            const geminiChatSendBtn = document.getElementById('geminiChatSendBtn');


            // --- Stato dell'applicazione ---
            let players = [];
            let matches = [];
            let tournaments = [];
            let singleHistoryChart = null;
            let comparisonChart = null;
            let currentlyViewingPlayerId = null;
            let matchIdToDelete = null;
            let playerIdToDelete = null;
            let tournamentIdToDelete = null;
            let matchesToDeleteIds = [];
            let currentTournamentMatch = { tournamentId: null, matchId: null };
            let leaderboardSort = { by: 'elo', order: 'desc' };
            let matchHistorySort = 'date_desc';
            let comparisonMode = 'general';
            let fileHandle = null;
            let cachedEloExplanation = null;
            let preMatchCommentaryAbortController = null;
            const K_FACTOR = 32;
            const INITIAL_ELO = 1500;
            const CHART_COLORS = ['#148cb4', '#dc3545', '#28a745', '#6f42c1', '#fd7e14', '#20c997', '#ffc107', '#6610f2'];
            let tourneyCreationState = {};

            // --- Helper Functions ---
            const getPlayer = (id) => players.find(p => p.id === id);
            const getPlayers = (idArray) => idArray.map(id => getPlayer(id));
            const calculateMedian = (arr) => {
                if (!arr || arr.length === 0) return 0;
                const sorted = arr.slice().sort((a,b) => a - b);
                const mid = Math.floor(sorted.length / 2);
                return sorted.length % 2 !== 0 ? sorted[mid] : (sorted[mid - 1] + sorted[mid]) / 2;
            };
            const openModal = (modalElement) => {
                modalElement.classList.remove('hidden');
                body.classList.add('modal-open');
            };
            const closeModal = (modalElement) => {
                modalElement.classList.add('hidden');
                body.classList.remove('modal-open');
            };
            // Funzione "cifratura" API Key
            const encryptKey = (key) => btoa(key);
            const decryptKey = (encryptedKey) => atob(encryptedKey);

            // --- Funzioni Principali ---

            function showMessage(text, isError = false) {
                messageArea.textContent = text;
                messageArea.classList.remove('hidden', 'bg-red-500', 'bg-green-500');
                messageArea.classList.add(isError ? 'bg-red-500' : 'bg-green-500');
                setTimeout(() => messageArea.classList.add('hidden'), 4000);
            }

            function addPlayer() {
                const name = playerNameInput.value.trim();
                if (!name) return showMessage("Il nome del giocatore non pu√≤ essere vuoto.", true);
                if (players.some(p => p.name.toLowerCase() === name.toLowerCase())) return showMessage("Questo giocatore esiste gi√†.", true);

                players.push({
                    id: Date.now(),
                    name: name,
                    elo: INITIAL_ELO,
                    history: [{ date: new Date(0).toISOString().split('T')[0], elo: INITIAL_ELO }],
                    gamesPlayed: 0
                });
                playerNameInput.value = '';
                saveAndRender();
            }

            function confirmDeletePlayer(id) {
                const player = getPlayer(id);
                if (!player) return;

                if (player.gamesPlayed > 0) {
                    showMessage(`Non puoi eliminare ${player.name} perch√© ha gi√† disputato delle partite.`, true);
                    return;
                }

                playerIdToDelete = id;
                const summaryText = document.getElementById('playerDeleteSummaryText');
                summaryText.textContent = `Sei sicuro di voler eliminare ${player.name}? L'azione √® irreversibile.`;
                openModal(confirmPlayerDeleteModal);
            }

            function deletePlayer() {
                if (playerIdToDelete === null) return;
                players = players.filter(p => p.id !== playerIdToDelete);
                saveAndRender();
                closeModal(document.getElementById('confirmPlayerDeleteModal'));
                showMessage("Giocatore eliminato con successo.");
                playerIdToDelete = null;
            }

            function preRecordMatch() {
                if (!matchDateInput.value) return showMessage("Devi inserire una data valida.", true);
                const playerIds = allSelects.map(s => s.value);
                if (playerIds.some(id => id === '')) return showMessage("Seleziona un giocatore per ogni ruolo.", true);
                if (new Set(playerIds).size !== 4) return showMessage("Ogni giocatore pu√≤ essere selezionato una sola volta.", true);

                const scoreA = parseInt(scoreAInput.value);
                const scoreB = parseInt(scoreBInput.value);

                if (scoreA === scoreB) {
                    return showMessage("Una partita non pu√≤ finire in pareggio.", true);
                }
                
                if (isNaN(scoreA) || isNaN(scoreB)) {
                    return showMessage("Inserisci un punteggio valido.", true);
                }
                
                const winnerRadio = document.querySelector('input[name="winner"]:checked');
                if (!winnerRadio) {
                    return showMessage("Seleziona un vincitore.", true);
                }

                const teamAPlayers = { attack: getPlayer(parseInt(teamASelects.attack.value)), defense: getPlayer(parseInt(teamASelects.defense.value)) };
                const teamBPlayers = { attack: getPlayer(parseInt(teamBSelects.attack.value)), defense: getPlayer(parseInt(teamBSelects.defense.value)) };
                const winner = winnerRadio.value;

                recordSummary.innerHTML = `
                    <p><strong>Data:</strong> ${new Date(matchDateInput.value).toLocaleDateString('it-IT')}</p>
                    <p><strong>Squadra Blu:</strong> ‚öîÔ∏è ${teamAPlayers.attack.name} & üõ°Ô∏è ${teamAPlayers.defense.name}</p>
                    <p><strong>Squadra Rossa:</strong> ‚öîÔ∏è ${teamBPlayers.attack.name} & üõ°Ô∏è ${teamBPlayers.defense.name}</p>
                    <p><strong>Punteggio:</strong> <span class="font-bold">${scoreA} - ${scoreB}</span></p>
                    <p><strong>Vincitore:</strong> <span class="font-bold ${winner === 'A' ? 'team-blue-color' : 'team-red-color'}">Squadra ${winner === 'A' ? 'Blu' : 'Rossa'}</span></p>
                `;
                openModal(confirmRecordModal);
            }

            function recordMatch() {
                const newMatch = {
                    id: Date.now(),
                    date: matchDateInput.value,
                    teamA: { attack: parseInt(teamASelects.attack.value), defense: parseInt(teamASelects.defense.value) },
                    teamB: { attack: parseInt(teamBSelects.attack.value), defense: parseInt(teamBSelects.defense.value) },
                    scoreA: parseInt(scoreAInput.value),
                    scoreB: parseInt(scoreBInput.value),
                    winner: document.querySelector('input[name="winner"]:checked').value,
                    commentaries: { critic: null, coach: null }
                };
                matches.push(newMatch);

                recalculateAllElos();
                showMessage("Partita registrata con successo!");
                
                saveAndRender();
            }

            function openConfirmationModal(matchId) {
                matchIdToDelete = matchId;
                openModal(confirmDeleteModal);
            }

            function deleteMatch(matchId) {
                matches = matches.filter(m => m.id !== matchId);
            }

            function getAllHistoricalMatches() {
                const allMatches = [...matches.map(m => ({...m, isTournament: false}))];
                tournaments.forEach(t => {
                    t.rounds.flat().forEach(match => {
                        if (match.winnerTeamId) {
                            const teamA = t.teams.find(team => team.id === match.teamAId);
                            const teamB = t.teams.find(team => team.id === match.teamBId);
                            if (!teamA || !teamB || !match.teamA_attackId || !match.teamB_attackId) return;

                            allMatches.push({
                                id: `t-${match.id}`,
                                date: t.date,
                                teamA: {
                                    attack: match.teamA_attackId,
                                    defense: teamA.player1Id === match.teamA_attackId ? teamA.player2Id : teamA.player1Id
                                },
                                teamB: {
                                    attack: match.teamB_attackId,
                                    defense: teamB.player1Id === match.teamB_attackId ? teamB.player2Id : teamB.player1Id
                                },
                                winner: teamA.id === match.winnerTeamId ? 'A' : 'B',
                                isTournament: true,
                                tournamentName: t.name,
                                eloChange: match.eloChange,
                                teamA_elos: match.teamA_elos,
                                teamB_elos: match.teamB_elos,
                                scoreA: null, 
                                scoreB: null,
                                commentaries: { critic: null, coach: null }
                            });
                        }
                    });
                });
                return allMatches.sort((a, b) => new Date(b.date) - new Date(a.date));
            }

            function recalculateAllElos() {
                const allHistoricalMatches = getAllHistoricalMatches().sort((a, b) => new Date(a.date) - new Date(b.date));

                players.forEach(player => {
                    player.history = [player.history[0] || { date: new Date(0).toISOString().split('T')[0], elo: INITIAL_ELO }];
                    player.elo = INITIAL_ELO;
                    player.gamesPlayed = 0;
                });

                allHistoricalMatches.forEach(matchData => {
                    const affectsElo = !matchData.isTournament || (tournaments.find(t => t.name === matchData.tournamentName)?.affectsElo ?? false);

                    const teamAPlayers = { attack: getPlayer(matchData.teamA.attack), defense: getPlayer(matchData.teamA.defense) };
                    const teamBPlayers = { attack: getPlayer(matchData.teamB.attack), defense: getPlayer(matchData.teamB.defense) };

                    if (!teamAPlayers.attack || !teamAPlayers.defense || !teamBPlayers.attack || !teamBPlayers.defense) return;

                    const currentTeamAElos = { attack: teamAPlayers.attack.elo, defense: teamAPlayers.defense.elo };
                    const currentTeamBElos = { attack: teamBPlayers.attack.elo, defense: teamBPlayers.defense.elo };

                    let eloChange = 0;
                    if (affectsElo) {
                        const teamAElo = (currentTeamAElos.attack + currentTeamAElos.defense) / 2;
                        const teamBElo = (currentTeamBElos.attack + currentTeamBElos.defense) / 2;
                        const expectedScoreA = 1 / (1 + Math.pow(10, (teamBElo - teamAElo) / 400));
                        const actualScoreA = (matchData.winner === 'A') ? 1 : 0;
                        eloChange = K_FACTOR * (actualScoreA - expectedScoreA);

                        const applyIndividualEloChanges = (teamPlayers, baseChange) => {
                            const p1 = teamPlayers.attack;
                            const p2 = teamPlayers.defense;
                            const elo1 = p1.elo;
                            const elo2 = p2.elo;

                            // 1. Calcola il fattore di aggiustamento basato sulla differenza di ELO
                            const eloDiff = Math.abs(elo1 - elo2);
                            const eloAdjustmentFactor = Math.min(eloDiff / 800, 0.3); // Fino al 30% di aggiustamento. 400 ELO di diff = 15%

                            let strongerPlayer, weakerPlayer;
                            if (elo1 > elo2) {
                                strongerPlayer = p1;
                                weakerPlayer = p2;
                            } else {
                                strongerPlayer = p2;
                                weakerPlayer = p1;
                            }

                            let strongerPlayerChange, weakerPlayerChange;
                            if (baseChange > 0) { // Squadra vincente
                                strongerPlayerChange = baseChange * (1 - eloAdjustmentFactor);
                                weakerPlayerChange = baseChange * (1 + eloAdjustmentFactor);
                            } else { // Squadra perdente
                                strongerPlayerChange = baseChange * (1 + eloAdjustmentFactor);
                                weakerPlayerChange = baseChange * (1 - eloAdjustmentFactor);
                            }

                            // 2. Applica un fattore di aggiustamento per il ruolo (l'attaccante ha un impatto maggiore)
                            const roleAdjustmentFactor = 0.05; // 5% di impatto in pi√π per l'attaccante
                            const attackerChange = (p1 === strongerPlayer ? strongerPlayerChange : weakerPlayerChange) * (1 + roleAdjustmentFactor);
                            const defenderChange = (p2 === strongerPlayer ? strongerPlayerChange : weakerPlayerChange) * (1 - roleAdjustmentFactor);

                            // 3. Applica i cambiamenti e aggiorna la history
                            const newEloAttacker = Math.round(p1.elo + attackerChange);
                            p1.elo = newEloAttacker;
                            p1.history.push({ date: matchData.date, elo: newEloAttacker });

                            const newEloDefender = Math.round(p2.elo + defenderChange);
                            p2.elo = newEloDefender;
                            p2.history.push({ date: matchData.date, elo: newEloDefender });
                        };

                        applyIndividualEloChanges(teamAPlayers, eloChange);
                        applyIndividualEloChanges(teamBPlayers, -eloChange);
                    }

                    [...Object.values(teamAPlayers), ...Object.values(teamBPlayers)].forEach(p => {
                        p.gamesPlayed = (p.gamesPlayed || 0) + 1;
                    });

                    let originalMatch;
                    if (matchData.isTournament) {
                        // This part might need adjustment if tournament match IDs are not unique enough
                        const tournament = tournaments.find(t => t.name === matchData.tournamentName);
                        if (tournament) {
                            originalMatch = tournament.rounds.flat().find(m => `t-${m.id}` === matchData.id);
                        }
                    } else {
                        originalMatch = matches.find(m => m.id === matchData.id);
                    }

                    if (originalMatch) {
                        originalMatch.eloChange = eloChange;
                        originalMatch.teamA_elos = currentTeamAElos;
                        originalMatch.teamB_elos = currentTeamBElos;
                    }
                });
            }

            // --- Funzioni di Rendering e UI ---
            function render() {
                renderPlayers();
                renderMatches();
                renderTournaments();
                renderComparisonSelectors();
            }

            function renderPlayers(playerData = null, fromFilter = false) {
                const isOverall = !playerData;
                const sourcePlayers = playerData || players.filter(p => p.gamesPlayed > 0);
                 
                if (isOverall) {
                    unrankedPlayersCard.style.display = 'block';
                    sourcePlayers.sort((a, b) => {
                        if (leaderboardSort.by === 'elo') return leaderboardSort.order === 'desc' ? b.elo - a.elo : a.elo - b.elo;
                        return leaderboardSort.order === 'asc' ? a.name.localeCompare(b.name) : b.name.localeCompare(a.name);
                    });
                } else {
                     unrankedPlayersCard.style.display = 'none';
                     sourcePlayers.sort((a, b) => b.elo - a.elo);
                }

                leaderboard.innerHTML = sourcePlayers.length ? '' : `<p class="text-gray-500 text-center py-4">Nessun giocatore trovato.</p>`;
                sourcePlayers.forEach((player, index) => {
                    let rankClass = '';
                    if((isOverall && leaderboardSort.by === 'elo' && leaderboardSort.order === 'desc') || !isOverall) {
                        if (index === 0) rankClass = 'rank-1';
                        else if (index === 1) rankClass = 'rank-2';
                        else if (index === 2) rankClass = 'rank-3';
                    }
                    const playerRow = document.createElement('div');
                    playerRow.className = `flex items-center justify-between p-3 rounded-lg hover:bg-gray-100 transition-colors cursor-pointer ${rankClass}`;
                    playerRow.innerHTML = `
                        <div class="flex items-center gap-4">
                            <span class="font-bold text-lg w-8 text-center">${index + 1}</span>
                            <span class="text-lg font-medium text-gray-800">${player.name}</span>
                        </div>
                        <div class="flex items-center gap-4">
                            <span class="font-bold text-lg" style="color: var(--team-blue)">${Math.round(player.elo)}</span>
                            ${isOverall ? `<button class="btn-danger text-xs px-2 py-1 rounded" title="Elimina Giocatore">X</button>` : ''}
                        </div>`;
                    if(isOverall) {
                        playerRow.querySelector('button').addEventListener('click', e => { e.stopPropagation(); confirmDeletePlayer(player.id); });
                    }
                    playerRow.addEventListener('click', () => openHistoryModal(player.id));
                    leaderboard.appendChild(playerRow);
                });
                
                if (isOverall) {
                    getGeminiAnalysisForLeaderboard(sourcePlayers, true);
                    const unrankedPlayers = players.filter(p => p.gamesPlayed === 0);
                    unrankedPlayers.sort((a, b) => a.name.localeCompare(b.name));
                    unrankedPlayersContainer.innerHTML = unrankedPlayers.length ? '' : `<p class="text-gray-500 text-center py-4">Tutti i giocatori sono classificati.</p>`;
                    unrankedPlayers.forEach(player => {
                        const playerRow = document.createElement('div');
                        playerRow.className = 'flex items-center justify-between p-3 rounded-lg hover:bg-gray-100 transition-colors cursor-pointer';
                        playerRow.innerHTML = `
                             <span class="text-lg font-medium text-gray-800">${player.name}</span>
                             <div class="flex items-center gap-4">
                                 <span class="font-bold text-lg text-gray-400">${Math.round(player.elo)}</span>
                                 <button class="btn-danger text-xs px-2 py-1 rounded" title="Elimina Giocatore">Elimina</button>
                             </div>`;
                        playerRow.querySelector('button').addEventListener('click', e => { e.stopPropagation(); confirmDeletePlayer(player.id); });
                        playerRow.addEventListener('click', () => openHistoryModal(player.id));
                        unrankedPlayersContainer.appendChild(playerRow);
                    });
                }
                
                if (fromFilter) {
                    getGeminiAnalysisForLeaderboard(sourcePlayers, false);
                }

                allSelects.forEach(select => {
                    const currentValue = select.value;
                    select.innerHTML = '<option value="">Seleziona...</option>';
                    players.sort((a, b) => a.name.localeCompare(b.name)).forEach(player => {
                        select.innerHTML += `<option value="${player.id}">${player.name}</option>`;
                    });
                    select.value = currentValue;
                });
            }

            function handleLeaderboardFilter() {
                 const startDate = leaderboardStartDate.value;
                 const endDate = leaderboardEndDate.value;
                 if(!startDate || !endDate) return showMessage("Seleziona un intervallo di date valido.", true);

                 const playersAtDate = players.map(p => {
                     const historyUntilDate = p.history.filter(h => h.date <= endDate);
                     const elo = historyUntilDate.length > 0 ? historyUntilDate[historyUntilDate.length - 1].elo : INITIAL_ELO;
                     return {...p, elo: Math.round(elo) };
                 }).filter(p => {
                     // Include only players who played in the period
                     return p.history.some(h => h.date >= startDate && h.date <= endDate);
                 });


                 renderPlayers(playersAtDate, true);
            }

            function renderMatches(container = matchHistoryContainer, matchesToRender = null) {
                const startDate = matchHistoryStartDate.value;
                const endDate = matchHistoryEndDate.value;
                let allHistoricalMatches = matchesToRender || getAllHistoricalMatches();
            
                if (!matchesToRender) {
                    let filteredMatches = allHistoricalMatches;
                    if (startDate && endDate) {
                        filteredMatches = allHistoricalMatches.filter(m => m.date >= startDate && m.date <= endDate);
                    }
                    allHistoricalMatches = filteredMatches;
            
                    allHistoricalMatches.sort((a, b) => {
                        const [sortBy, sortOrder] = matchHistorySort.split('_');
                        if (sortBy === 'date') return sortOrder === 'desc' ? new Date(b.date) - new Date(a.date) : new Date(a.date) - new Date(b.date);
                        if (sortBy === 'elo') {
                            const avgEloA = (a.teamA_elos?.attack + a.teamA_elos?.defense + a.teamB_elos?.attack + a.teamB_elos?.defense) / 4 || 0;
                            const avgEloB = (b.teamA_elos?.attack + b.teamA_elos?.defense + b.teamB_elos?.attack + b.teamB_elos?.defense) / 4 || 0;
                            return sortOrder === 'desc' ? avgEloB - avgEloA : avgEloA - avgEloB;
                        }
                        return 0;
                    });
                }
            
                container.innerHTML = allHistoricalMatches.length ? '' : `<p class="text-gray-500 text-center py-4">Nessuna partita trovata.</p>`;
            
                allHistoricalMatches.forEach(match => {
                    const teamAPlayers = { attack: getPlayer(match.teamA.attack), defense: getPlayer(match.teamA.defense) };
                    const teamBPlayers = { attack: getPlayer(match.teamB.attack), defense: getPlayer(match.teamB.defense) };
                    if (!teamAPlayers.attack || !teamAPlayers.defense || !teamBPlayers.attack || !teamBPlayers.defense) {
                        console.warn("Skipping match with missing player(s):", match);
                        return; // Skip rendering this match if any player is missing
                    }
            
                    const isEloActive = !match.isTournament || (tournaments.find(t => t.name === match.tournamentName)?.affectsElo ?? false);
                    const eloChangeStringA = (isEloActive && match.eloChange != null) ? (match.winner === 'A' ? `+${Math.round(match.eloChange)}` : `${Math.round(match.eloChange)}`) : 'N/A';
                    const eloChangeStringB = (isEloActive && match.eloChange != null) ? (match.winner === 'B' ? `+${Math.round(-match.eloChange)}` : `${Math.round(-match.eloChange)}`) : 'N/A';
                    const eloChangeClassA = (isEloActive && match.eloChange != null) ? (eloChangeStringA.startsWith('+') ? 'text-green-600' : 'text-red-600') : 'text-gray-400';
                    const eloChangeClassB = (isEloActive && match.eloChange != null) ? (eloChangeStringB.startsWith('+') ? 'text-green-600' : 'text-red-600') : 'text-gray-400';
                    const matchIcon = match.isTournament ? 'üèÜ' : 'ü§ù';
                    const matchTitle = match.isTournament ? match.tournamentName : 'Partita Amichevole';
            
                    const matchRow = document.createElement('div');
                    matchRow.className = 'border border-gray-200 rounded-lg';
                    
                    const hasScore = typeof match.scoreA === 'number' && typeof match.scoreB === 'number' && !isNaN(match.scoreA) && !isNaN(match.scoreB);
            
                    matchRow.innerHTML = `
                        <button class="player-match-accordion-header w-full p-3 text-left bg-gray-50 hover:bg-gray-100 rounded-t-lg">
                            <div class="grid grid-cols-1 md:grid-cols-4 items-center gap-2">
                                <div class="text-sm text-gray-600 font-medium">
                                    ${new Date(match.date).toLocaleDateString('it-IT', { day: '2-digit', month: 'short', year: 'numeric' })}
                                    <span class="ml-2" title="${matchTitle}">${matchIcon}</span>
                                </div>
                                <div class="md:col-span-2 flex flex-col md:flex-row md:items-center justify-center text-center gap-2 md:gap-4 text-sm">
                                    <span class="truncate ${match.winner === 'A' ? 'font-bold team-blue-color' : 'text-gray-500'}">
                                        ${teamAPlayers.attack.name} & ${teamAPlayers.defense.name} 
                                        ${hasScore ? `<span class="font-bold text-lg ml-1">${match.scoreA}</span>` : '<span class="font-bold text-lg ml-1 text-gray-400">N.D.</span>'}
                                        <span class="text-xs font-normal ${eloChangeClassA}">(${eloChangeStringA})</span>
                                    </span>
                                    <span class="text-gray-400 font-bold text-xs">VS</span>
                                    <span class="truncate ${match.winner === 'B' ? 'font-bold team-red-color' : 'text-gray-500'}">
                                        ${teamBPlayers.attack.name} & ${teamBPlayers.defense.name} 
                                        ${hasScore ? `<span class="font-bold text-lg ml-1">${match.scoreB}</span>` : '<span class="font-bold text-lg ml-1 text-gray-400">N.D.</span>'}
                                        <span class="text-xs font-normal ${eloChangeClassB}">(${eloChangeStringB})</span>
                                    </span>
                                </div>
                                <div class="flex justify-end items-center gap-2">
                                    <button class="btn btn-secondary text-xs px-2 py-1 rounded generate-commentary-btn" data-match-id="${match.id}" ${match.isTournament ? 'style="display:none;"' : ''}>Analisi AI</button>
                                    ${container === matchHistoryContainer && !match.isTournament ? `<button class="btn-danger text-xs px-2 py-1 rounded" data-id="${match.id}">Elimina</button>` : ''}
                                    <svg class="w-5 h-5 shrink-0 transition-transform duration-300" fill="none" viewBox="0 0 24 24" stroke="currentColor"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M19 9l-7 7-7-7" /></svg>
                                </div>
                            </div>
                        </button>
                        <div class="player-match-accordion-content hidden p-4 border-t border-gray-200 bg-white rounded-b-lg space-y-4">
                            <div class="grid grid-cols-1 md:grid-cols-2 gap-4">
                                <div>
                                    <h4 class="font-semibold text-gray-800 text-sm mb-2 flex items-center gap-2"><span class="text-base">üéôÔ∏è</span> La cronaca del critico</h4>
                                    <p class="text-sm italic text-gray-600 border-l-2 pl-2 border-gray-200 min-h-[40px]">${match.commentaries?.critic || "Nessun commento generato."}</p>
                                </div>
                                <div>
                                    <h4 class="font-semibold text-gray-800 text-sm mb-2 flex items-center gap-2"><span class="text-base">ü§ñ</span> L'analisi del coach</h4>
                                    <p class="text-sm italic text-gray-600 border-l-2 pl-2 border-gray-200 min-h-[40px]">${match.commentaries?.coach || "Nessun commento generato."}</p>
                                </div>
                            </div>
                             <div class="grid grid-cols-1 md:grid-cols-2 gap-4 mt-4 pt-4 border-t">
                                <div class="team-blue-color">
                                    <h4 class="font-bold border-b pb-1 mb-2">Squadra Blu (ELO Medio: ${match.teamA_elos ? Math.round((match.teamA_elos.attack + match.teamA_elos.defense) / 2) : 'N/A'})</h4>
                                    <p>‚öîÔ∏è ${teamAPlayers.attack.name}: <span class="font-semibold">${match.teamA_elos ? match.teamA_elos.attack : 'N/A'}</span></p>
                                    <p>üõ°Ô∏è ${teamAPlayers.defense.name}: <span class="font-semibold">${match.teamA_elos ? match.teamA_elos.defense : 'N/A'}</span></p>
                                </div>
                                <div class="team-red-color">
                                    <h4 class="font-bold border-b pb-1 mb-2">Squadra Rossa (ELO Medio: ${match.teamB_elos ? Math.round((match.teamB_elos.attack + match.teamB_elos.defense) / 2) : 'N/A'})</h4>
                                    <p>‚öîÔ∏è ${teamBPlayers.attack.name}: <span class="font-semibold">${match.teamB_elos ? match.teamB_elos.attack : 'N/A'}</span></p>
                                    <p>üõ°Ô∏è ${teamBPlayers.defense.name}: <span class="font-semibold">${match.teamB_elos ? match.teamB_elos.defense : 'N/A'}</span></p>
                                </div>
                            </div>
                        </div>
                    `;
            
                    if (container === matchHistoryContainer && !match.isTournament) {
                        const deleteBtn = matchRow.querySelector('button[data-id]');
                        if(deleteBtn) deleteBtn.addEventListener('click', (e) => { e.stopPropagation(); openConfirmationModal(match.id); });
                    }
                    container.appendChild(matchRow);
                });
            }

            function renderComparisonSelectors() {
                const sortedPlayers = [...players].sort((a,b) => a.name.localeCompare(b.name));

                comparisonPlayerList.innerHTML = '';
                synergyPivotPlayer.innerHTML = '<option value="">Seleziona...</option>';
                partnerFinderPlayer.innerHTML = '<option value="">Seleziona Giocatore</option>';

                sortedPlayers.forEach(player => {
                    const optionHTML = `<option value="${player.id}">${player.name}</option>`;
                    comparisonPlayerList.innerHTML += `
                    <label class="flex items-center space-x-2 cursor-pointer p-1 rounded hover:bg-gray-100">
                        <input type="checkbox" value="${player.id}" class="rounded border-gray-300 text-[--team-blue] focus:ring-[--team-blue]">
                        <span>${player.name}</span>
                    </label>`;
                    synergyPivotPlayer.innerHTML += optionHTML;
                    partnerFinderPlayer.innerHTML += optionHTML;
                });
            }

            function calculateRoleBasedElo(player, role, allMatches) {
                 if (!player) return INITIAL_ELO;

                 const roleSpecificMatches = allMatches
                     .filter(m => (m.teamA[role] === player.id || m.teamB[role] === player.id))
                     .sort((a, b) => new Date(a.date) - new Date(b.date));

                 let roleElo = INITIAL_ELO;

                 roleSpecificMatches.forEach(match => {
                     const isPlayerInTeamA = match.teamA[role] === player.id;
                     const partnerRole = role === 'attack' ? 'defense' : 'attack';

                     const teamA_elos = match.teamA_elos;
                     const teamB_elos = match.teamB_elos;

                     if (!teamA_elos || !teamB_elos) return;

                     const teamAElo = (teamA_elos.attack + teamA_elos.defense) / 2;
                     const teamBElo = (teamB_elos.attack + teamB_elos.defense) / 2;

                     const expectedScore = 1 / (1 + Math.pow(10, ((isPlayerInTeamA ? teamBElo : teamAElo) - roleElo) / 400));
                     const actualScore = (isPlayerInTeamA && match.winner === 'A') || (!isPlayerInTeamA && match.winner === 'B') ? 1 : 0;
                     
                     const eloChange = K_FACTOR * (actualScore - expectedScore);
                     roleElo += eloChange;
                 });

                 return Math.round(roleElo);
            }

            function updateTeamEloDisplays() {
                const allHistoricalMatches = getAllHistoricalMatches();
                const pA_att_id = parseInt(teamASelects.attack.value);
                const pA_def_id = parseInt(teamASelects.defense.value);
                if (pA_att_id && pA_def_id && pA_att_id !== pA_def_id) {
                    const p1 = getPlayer(pA_att_id);
                    const p2 = getPlayer(pA_def_id);
                    const p1_role_elo = calculateRoleBasedElo(p1, 'attack', allHistoricalMatches);
                    const p2_role_elo = calculateRoleBasedElo(p2, 'defense', allHistoricalMatches);
                    teamAEloDisplay.textContent = `ELO: ${Math.round((p1_role_elo + p2_role_elo) / 2)}`;
                } else {
                    teamAEloDisplay.textContent = 'ELO: -';
                }

                const pB_att_id = parseInt(teamBSelects.attack.value);
                const pB_def_id = parseInt(teamBSelects.defense.value);
                if (pB_att_id && pB_def_id && pB_att_id !== pB_def_id) {
                    const p1 = getPlayer(pB_att_id);
                    const p2 = getPlayer(pB_def_id);
                    const p1_role_elo = calculateRoleBasedElo(p1, 'attack', allHistoricalMatches);
                    const p2_role_elo = calculateRoleBasedElo(p2, 'defense', allHistoricalMatches);
                    teamBEloDisplay.textContent = `ELO: ${Math.round((p1_role_elo + p2_role_elo) / 2)}`;
                } else {
                    teamBEloDisplay.textContent = 'ELO: -';
                }

                teamAssistantBtn.disabled = !((pA_att_id && pA_def_id && pA_att_id !== pA_def_id) || (pB_att_id && pB_def_id && pB_att_id !== pB_def_id));
                
                const allPlayerIds = [pA_att_id, pA_def_id, pB_att_id, pB_def_id].filter(id => !isNaN(id));
                if (new Set(allPlayerIds).size === 4) {
                    generatePreMatchCommentary();
                } else {
                    preMatchCommentaryContainer.classList.add('hidden');
                }
            }


            // --- Analisi & Matchmaking ---
            function openTeamAssistantModal() {
                 const currentTab = document.querySelector('.assistant-tab.active').dataset.tab;
                 if(currentTab === 'opponents') showOpponentProposals();
                 else renderPartnerFinder();
                 openModal(teamAssistantModal);
            }

            function showOpponentProposals() {
                let referenceTeam = null;
                const allHistoricalMatches = getAllHistoricalMatches();

                let p_att_id = parseInt(teamASelects.attack.value);
                let p_def_id = parseInt(teamASelects.defense.value);

                if (p_att_id && p_def_id && p_att_id !== p_def_id) {
                    referenceTeam = {
                        attack: getPlayer(p_att_id),
                        defense: getPlayer(p_def_id)
                    };
                } else {
                     p_att_id = parseInt(teamBSelects.attack.value);
                     p_def_id = parseInt(teamBSelects.defense.value);
                     if (p_att_id && p_def_id && p_att_id !== p_def_id) {
                        referenceTeam = {
                            attack: getPlayer(p_att_id),
                            defense: getPlayer(p_def_id)
                        };
                     }
                }

                if(!referenceTeam) {
                     opponentPairsList.innerHTML = `<p class="text-center text-gray-500 py-4">Seleziona una squadra completa (Blu o Rossa) per trovare avversari.</p>`;
                     return;
                }

                const ref_att_elo = calculateRoleBasedElo(referenceTeam.attack, 'attack', allHistoricalMatches);
                const ref_def_elo = calculateRoleBasedElo(referenceTeam.defense, 'defense', allHistoricalMatches);
                const teamElo = (ref_att_elo + ref_def_elo) / 2;

                const availablePlayers = players.filter(p => p.id !== referenceTeam.attack.id && p.id !== referenceTeam.defense.id);
                if (availablePlayers.length < 2) {
                    opponentPairsList.innerHTML = `<p class="text-center text-gray-500 py-4">Non ci sono abbastanza giocatori per formare una squadra avversaria.</p>`;
                    return;
                };

                let opponentPairs = [];
                for (let i = 0; i < availablePlayers.length; i++) {
                    for (let j = 0; j < availablePlayers.length; j++) {
                        if (i === j) continue;
                        const p_att = availablePlayers[i];
                        const p_def = availablePlayers[j];
                        
                        const p_att_role_elo = calculateRoleBasedElo(p_att, 'attack', allHistoricalMatches);
                        const p_def_role_elo = calculateRoleBasedElo(p_def, 'defense', allHistoricalMatches);

                        opponentPairs.push({ attack: p_att, defense: p_def, avgElo: (p_att_role_elo + p_def_role_elo) / 2 });
                    }
                }

                const uniquePairs = opponentPairs.filter((pair, index, self) =>
                    index === self.findIndex(p => p.attack.id === pair.attack.id && p.defense.id === pair.defense.id)
                );
                
                const proposals = {
                    "üèÜ La Partita Equilibrata": { pair: [...uniquePairs].sort((a,b) => Math.abs(a.avgElo - teamElo) - Math.abs(b.avgElo - teamElo))[0], desc: "La sfida pi√π bilanciata sulla carta, basata sull'ELO specifico per ruolo." },
                    "‚öîÔ∏è Scontro tra Titani": { pair: [...uniquePairs].sort((a, b) => b.avgElo - a.avgElo)[0], desc: "Affronta la coppia con l'ELO combinato per ruolo pi√π alto." },
                };

                opponentPairsList.innerHTML = '';
                Object.entries(proposals).forEach(([title, data]) => {
                    const {pair, desc} = data;
                    if (!pair) return; // Salta se non √® possibile generare una coppia
                    const card = document.createElement('div');
                    card.className = 'p-4 border rounded-lg cursor-pointer hover:bg-gray-50 hover:border-gray-400 transition-all';
                    card.dataset.attackId = pair.attack.id;
                    card.dataset.defenseId = pair.defense.id;
                    card.innerHTML = `
                        <div class="flex justify-between items-start">
                            <div>
                                <h4 class="font-bold text-lg text-gray-800">${title}</h4>
                                <p class="text-sm text-gray-600 mt-1">${desc}</p>
                            </div>
                            <div class="text-right ml-4 flex-shrink-0">
                                <p class="font-bold text-lg" style="color:var(--team-blue)">${Math.round(pair.avgElo)}</p>
                                <p class="text-xs text-gray-500">ELO Medio</p>
                            </div>
                        </div>
                        <div class="mt-3 text-sm font-semibold">
                            <span>‚öîÔ∏è ${pair.attack.name}</span> &
                            <span>üõ°Ô∏è ${pair.defense.name}</span>
                        </div>`;
                    opponentPairsList.appendChild(card);
                });
            }

            function renderPartnerFinder() {
                const playerId = parseInt(partnerFinderPlayer.value);
                const playerRole = partnerFinderRole.value;
                const startDate = partnerFinderStartDate.value;
                const endDate = partnerFinderEndDate.value;

                if (!playerId) {
                    partnerList.innerHTML = `<p class="text-center text-gray-500 py-4">Seleziona un giocatore per iniziare.</p>`;
                    return;
                }
                const player = getPlayer(playerId);
                const partnerRole = playerRole === 'attack' ? 'defense' : 'attack';
                const availablePartners = players.filter(p => p.id !== playerId);
                const allHistoricalMatches = getAllHistoricalMatches();


                const rankedPartners = availablePartners.map(partner => {
                    const duoMatches = allHistoricalMatches.filter(m => {
                        const inPeriod = (!startDate || !endDate) || (m.date >= startDate && m.date <= endDate);
                        if (!inPeriod) return false;

                        const teamA = m.teamA;
                        const teamB = m.teamB;

                        return (teamA[playerRole] === player.id && teamA[partnerRole] === partner.id) ||
                               (teamB[playerRole] === player.id && teamB[partnerRole] === partner.id);
                    });

                    if (duoMatches.length === 0) {
                        const playerElo = calculateRoleBasedElo(player, playerRole, allHistoricalMatches);
                        const partnerElo = calculateRoleBasedElo(partner, partnerRole, allHistoricalMatches);
                        return { partner, matches: 0, wins: 0, medianElo: (playerElo + partnerElo) / 2, basedOn: 'elo' };
                    }

                    const wins = duoMatches.filter(m => {
                         const inTeamA = m.teamA[playerRole] === player.id;
                         return (inTeamA && m.winner === 'A') || (!inTeamA && m.winner === 'B');
                    }).length;

                    const teamElos = duoMatches.map(m => {
                         const inTeamA = m.teamA[playerRole] === player.id;
                         const elos = inTeamA ? m.teamA_elos : m.teamB_elos;
                         if(!elos) return 0;
                         return (elos.attack + elos.defense) / 2;
                    }).filter(e => e > 0);

                    return { partner, matches: duoMatches.length, wins, medianElo: calculateMedian(teamElos), basedOn: 'performance' };
                }).sort((a, b) => b.medianElo - a.medianElo);

                partnerList.innerHTML = '';
                 rankedPartners.forEach(data => {
                    const card = document.createElement('div');
                    card.className = 'flex justify-between items-center p-3 rounded-lg cursor-pointer bg-gray-50 hover:bg-gray-100';
                    card.dataset.playerId = playerId;
                    card.dataset.playerRole = playerRole;
                    card.dataset.partnerId = data.partner.id;
                    card.dataset.partnerRole = partnerRole;
                     const partnerRoleIcon = partnerRole === 'attack' ? '‚öîÔ∏è' : 'üõ°Ô∏è';
                    const partnerRoleText = partnerRole === 'attack' ? 'Attacco' : 'Difesa';
                    const losses = data.matches - data.wins;

                    card.innerHTML = `
                        <div>
                            <p class="font-semibold text-gray-800">${data.partner.name}</p>
                            <p class="text-sm text-gray-500">Proposto come: <span class="font-semibold">${partnerRoleIcon} ${partnerRoleText}</span></p>
                        </div>
                        <div class="text-right">
                             <p class="font-bold text-lg" style="color:var(--team-blue)">${Math.round(data.medianElo)} <span class="text-sm font-normal text-gray-500">${data.basedOn === 'performance' ? 'ELO Med.' : 'ELO St.'}</span></p>
                             ${data.matches > 0 ? `<div class="text-xs font-semibold mt-1"><span class="text-green-600">${data.wins}V</span> / <span class="text-red-600">${losses}S</span> <span class="text-gray-400 font-normal">(${data.matches} G)</span></div>` : '<p class="text-xs text-gray-400 mt-1">Nessun precedente</p>'}
                        </div>`;
                    partnerList.appendChild(card);
                });
            }


            // --- Gestione Grafici e Modal ---

            function openHistoryModal(playerId) {
                currentlyViewingPlayerId = playerId;
                const player = getPlayer(playerId);
                if (!player) return;

                playerProfileHeader.innerHTML = `
                    <h2 class="text-2xl font-bold text-gray-800">${player.name}</h2>
                    <p class="text-lg font-semibold" style="color: var(--team-blue)">ELO: ${Math.round(player.elo)}</p>`;

                const dates = player.history.slice(1).map(h => h.date).sort();
                historyStartDateInput.value = dates.length ? dates[0] : '';
                historyEndDateInput.value = dates.length ? dates[dates.length - 1] : '';

                switchTab('chart');
                updateAllPlayerData();
                getGeminiAnalysisForPlayer();
                openModal(historyModal);
            }

            function switchTab(tabName) {
                Object.values(playerAnalysisTabs).forEach(t => t.classList.remove('active'));
                Object.values(playerAnalysisContents).forEach(c => c.classList.add('hidden'));

                playerAnalysisTabs[tabName].classList.add('active');
                playerAnalysisContents[tabName].classList.remove('hidden');
            }

            function updateAllPlayerData() {
                renderSingleHistoryChart();
                renderPlayerMatchHistory();
                renderPlayerStats();
                renderPlayerTournaments();
                // Il giudizio AI viene aggiornato dal filtro data
            }

            function renderSingleHistoryChart() {
                const player = getPlayer(currentlyViewingPlayerId);
                const startDate = historyStartDateInput.value;
                const endDate = historyEndDateInput.value;
                const filteredHistory = player.history.slice(1).filter(h => h.date >= startDate && h.date <= endDate);

                if (singleHistoryChart) singleHistoryChart.destroy();
                singleHistoryChart = new Chart(document.getElementById('eloHistoryChart').getContext('2d'), {
                    type: 'line', data: {
                        labels: filteredHistory.map(h => new Date(h.date).toLocaleDateString('it-IT')),
                        datasets: [{
                            label: 'Punteggio ELO', data: filteredHistory.map(h => h.elo),
                            borderColor: 'var(--accent)', backgroundColor: 'rgba(255, 210, 46, 0.15)',
                            fill: true, tension: 0.1
                        }]
                    }, options: { responsive: true, maintainAspectRatio: false, scales: {
                        y: { ticks: { color: 'var(--text-muted)' }, grid: { color: 'rgba(0, 0, 0, 0.05)'}},
                        x: { ticks: { color: 'var(--text-muted)' }, grid: { display: false }}
                    }, plugins: { legend: { display: false } } }
                });
            }

            function getPlayerStatsForPeriod(playerId, startDate, endDate) {
                const player = getPlayer(playerId);
                const allHistoricalMatches = getAllHistoricalMatches();
                const playerMatches = allHistoricalMatches.filter(m => (m.teamA.attack === player.id || m.teamA.defense === player.id || m.teamB.attack === player.id || m.teamB.defense === player.id) && m.date >= startDate && m.date <= endDate);

                const wins = playerMatches.filter(m => {
                    const isPlayerInTeamA = m.teamA.attack === player.id || m.teamA.defense === player.id;
                    return (isPlayerInTeamA && m.winner === 'A') || (!isPlayerInTeamA && m.winner === 'B');
                }).length;
                const winRate = playerMatches.length > 0 ? (wins / playerMatches.length) * 100 : 0;

                const eloHistoryInRange = player.history.filter(h => h.date >= startDate && h.date <= endDate && new Date(h.date).getTime() !== 0);
                let eloChange = 0;
                if(eloHistoryInRange.length > 0) {
                    const startEloHistory = player.history.filter(h => h.date < startDate);
                    const startElo = startEloHistory.length > 0 ? startEloHistory[startEloHistory.length - 1].elo : player.history[0].elo;
                    const endElo = eloHistoryInRange[eloHistoryInRange.length - 1].elo;
                    eloChange = endElo - startElo;
                }

                const attackMatches = playerMatches.filter(m => m.teamA.attack === player.id || m.teamB.attack === player.id);
                const defenseMatches = playerMatches.filter(m => m.teamA.defense === player.id || m.teamB.defense === player.id);
                const attackWins = attackMatches.filter(m => ((m.teamA.attack === player.id && m.winner === 'A') || (m.teamB.attack === player.id && m.winner === 'B'))).length;
                const defenseWins = defenseMatches.filter(m => ((m.teamA.defense === player.id && m.winner === 'A') || (m.teamB.defense === player.id && m.winner === 'B'))).length;
                const attackWinRate = attackMatches.length > 0 ? (attackWins / attackMatches.length) * 100 : -1;
                const defenseWinRate = defenseMatches.length > 0 ? (defenseWins / defenseMatches.length) * 100 : -1;
                const bestRole = attackWinRate > defenseWinRate ? 'Attacco' : defenseWinRate > attackWinRate ? 'Difesa' : 'Indifferente';

                const teammateStats = {};
                playerMatches.forEach(match => {
                    const isPlayerInTeamA = match.teamA.attack === player.id || match.teamA.defense === player.id;
                    const playerRole = isPlayerInTeamA ? (match.teamA.attack === player.id ? 'attack' : 'defense') : (match.teamB.attack === player.id ? 'attack' : 'defense');
                    const team = isPlayerInTeamA ? match.teamA : match.teamB;
                    const teammateId = playerRole === 'attack' ? team.defense : team.attack;
                    if (!teammateId || !getPlayer(teammateId)) return;
                    if (!teammateStats[teammateId]) {
                        teammateStats[teammateId] = { name: getPlayer(teammateId).name, matches: 0, wins: 0 };
                    }
                    teammateStats[teammateId].matches++;
                    if ((isPlayerInTeamA && match.winner === 'A') || (!isPlayerInTeamA && match.winner === 'B')) {
                        teammateStats[teammateId].wins++;
                    }
                });

                const bestTeammate = Object.values(teammateStats).length > 0 ? Object.values(teammateStats).sort((a, b) => {
                    const aRate = a.matches > 0 ? a.wins / a.matches : 0;
                    const bRate = b.matches > 0 ? b.wins / b.matches : 0;
                    if (bRate !== aRate) return bRate - aRate;
                    return b.matches - a.matches; // secondary sort by matches played
                })[0] : null;

                return {
                    matchesPlayed: playerMatches.length,
                    winRate: winRate,
                    eloChange: eloChange,
                    bestRole: bestRole,
                    attackWinRate: attackWinRate,
                    defenseWinRate: defenseWinRate,
                    bestTeammate: bestTeammate ? { name: bestTeammate.name, winRate: (bestTeammate.wins / bestTeammate.matches) * 100, matches: bestTeammate.matches } : null,
                };
            }

            function renderPlayerStats() {
                const player = getPlayer(currentlyViewingPlayerId);
                const startDate = historyStartDateInput.value;
                const endDate = historyEndDateInput.value;
                const stats = getPlayerStatsForPeriod(currentlyViewingPlayerId, startDate, endDate);
                const allHistoricalMatches = getAllHistoricalMatches();
                const playerMatches = allHistoricalMatches.filter(m => (m.teamA.attack === player.id || m.teamA.defense === player.id || m.teamB.attack === player.id || m.teamB.defense === player.id) && m.date >= startDate && m.date <= endDate);

                // Summary Cards
                statsMatchesPlayed.textContent = stats.matchesPlayed;
                statsWinRate.textContent = stats.matchesPlayed > 0 ? `${Math.round(stats.winRate)}%` : '-';
                statsEloChange.textContent = `${stats.eloChange >= 0 ? '+' : ''}${Math.round(stats.eloChange)}`;
                statsEloChange.className = `text-2xl font-bold ${stats.eloChange > 0 ? 'text-green-600' : stats.eloChange < 0 ? 'text-red-600' : 'text-gray-800'}`;

                const blueMatches = playerMatches.filter(m => m.teamA.attack === player.id || m.teamA.defense === player.id);
                const blueWins = blueMatches.filter(m => m.winner === 'A').length;
                statsBlueWinRate.textContent = blueMatches.length > 0 ? `${Math.round((blueWins / blueMatches.length) * 100)}%` : '-';

                const redMatches = playerMatches.filter(m => m.teamB.attack === player.id || m.teamB.defense === player.id);
                const redWins = redMatches.filter(m => m.winner === 'B').length;
                statsRedWinRate.textContent = redMatches.length > 0 ? `${Math.round((redWins / redMatches.length) * 100)}%` : '-';

                statsBestRole.textContent = stats.bestRole === 'Indifferente' ? '-' : stats.bestRole === 'Attacco' ? '‚öîÔ∏è Attacco' : 'üõ°Ô∏è Difesa';

                // Teammate Synergy Analysis
                const teammateStats = {};
                playerMatches.forEach(match => {
                    const isPlayerInTeamA = match.teamA.attack === player.id || match.teamA.defense === player.id;
                    const playerRole = isPlayerInTeamA ? (match.teamA.attack === player.id ? 'attack' : 'defense') : (match.teamB.attack === player.id ? 'attack' : 'defense');
                    const team = isPlayerInTeamA ? match.teamA : match.teamB;
                    const teammateId = playerRole === 'attack' ? team.defense : team.attack;

                    if (!teammateId || !getPlayer(teammateId)) return;

                    if (!teammateStats[teammateId]) {
                        teammateStats[teammateId] = {
                            id: teammateId,
                            name: getPlayer(teammateId).name,
                            playerAttack: { matches: 0, wins: 0 },
                            playerDefense: { matches: 0, wins: 0 }
                        };
                    }

                    const stats = teammateStats[teammateId];
                    const scenario = playerRole === 'attack' ? stats.playerAttack : stats.playerDefense;
                    scenario.matches++;
                    if ((isPlayerInTeamA && match.winner === 'A') || (!isPlayerInTeamA && match.winner === 'B')) {
                        scenario.wins++;
                    }
                });

                const allCombinations = [];
                Object.values(teammateStats).forEach(partner => {
                    if (partner.playerAttack.matches > 0) {
                        allCombinations.push({
                            partnerId: partner.id, partnerName: partner.name,
                            playerRole: 'attack', partnerRole: 'defense',
                            ...partner.playerAttack,
                            winRate: (partner.playerAttack.wins / partner.playerAttack.matches) * 100
                        });
                    }
                    if (partner.playerDefense.matches > 0) {
                         allCombinations.push({
                            partnerId: partner.id, partnerName: partner.name,
                            playerRole: 'defense', partnerRole: 'attack',
                             ...partner.playerDefense,
                            winRate: (partner.playerDefense.wins / partner.playerDefense.matches) * 100
                        });
                    }
                });

                allCombinations.sort((a,b) => b.winRate - a.winRate || b.matches - a.matches);

                if (allCombinations.length > 0) {
                    const best = allCombinations[0];
                    bestSynergyHighlight.innerHTML = `
                        <h3 class="text-xl font-semibold text-gray-800 mb-2">Miglior Sinergia</h3>
                        <div class="p-4 bg-green-50 border-2 border-green-200 rounded-lg text-center">
                             <p class="text-lg">La tua miglior intesa √® con <strong class="text-green-800">${best.partnerName}</strong>.</p>
                             <p class="text-gray-700 mt-1">Con te in <strong class="text-green-800">${best.playerRole === 'attack' ? '‚öîÔ∏è Attacco' : 'üõ°Ô∏è Difesa'}</strong> e lui/lei in <strong class="text-green-800">${best.partnerRole === 'attack' ? '‚öîÔ∏è Attacco' : 'üõ°Ô∏è Difesa'}</strong>, avete una percentuale di vittoria del <strong class="text-2xl text-green-800">${best.winRate.toFixed(0)}%</strong> su ${best.matches} partite.</p>
                        </div>
                    `;
                } else {
                    bestSynergyHighlight.innerHTML = '';
                }

                bestTeammatesContainer.innerHTML = allCombinations.length ? '' : `<p class="text-center text-gray-500 py-4">Nessuna sinergia analizzabile in questo periodo.</p>`;
                allCombinations.forEach(combo => {
                    const losses = combo.matches - combo.wins;
                    const row = document.createElement('div');
                    row.className = 'flex items-center justify-between p-3 bg-gray-50 rounded-lg flex-wrap gap-2';
                    row.innerHTML = `
                        <div class="flex items-center gap-3">
                            <span class="font-semibold text-gray-800">${combo.partnerName}</span>
                            <span class="text-xs font-bold p-1 rounded ${combo.playerRole === 'attack' ? 'bg-red-100 text-red-700' : 'bg-blue-100 text-blue-700'}">Tu ${combo.playerRole === 'attack' ? '‚öîÔ∏è' : 'üõ°Ô∏è'}</span>
                        </div>
                        <div class="flex items-center gap-4 text-sm text-right">
                             <div class="font-semibold"><span class="text-green-600">${combo.wins}V</span> / <span class="text-red-600">${losses}S</span> <span class="text-gray-400 font-normal">(${combo.matches} G)</span></div>
                             <div class="font-bold text-lg" style="color:var(--team-blue)">${combo.winRate.toFixed(0)}%</div>
                        </div>`;
                    bestTeammatesContainer.appendChild(row);
                });
            }

            async function callGeminiAPI(prompt, containerElement, signal) {
                let apiKey = '';
                try {
                    const encryptedKey = localStorage.getItem('geminiApiKey');
                    if (encryptedKey) {
                        apiKey = decryptKey(encryptedKey);
                    } else {
                        throw new Error("API Key non trovata.");
                    }
                } catch (e) {
                     showMessage("API Key non trovata o non valida. Inseriscila nella Gestione Dati.", true);
                     if (containerElement) containerElement.innerHTML = `<p class="text-red-500">API Key di Gemini non configurata.</p>`;
                     return null;
                }

                try {
                    const response = await fetch(`https://generativelanguage.googleapis.com/v1beta/models/gemini-1.5-flash-latest:generateContent?key=${apiKey}`, {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({
                            contents: [{ parts: [{ text: prompt }] }],
                            generationConfig: {
                                temperature: 0.5,
                                topK: 1,
                                topP: 1,
                                maxOutputTokens: 8192,
                            },
                        }),
                        signal,
                    });

                    if (!response.ok) {
                        const errorData = await response.json();
                        throw new Error(errorData.error.message || `Errore API: ${response.status}`);
                    }

                    const data = await response.json();
                    const candidate = data.candidates?.[0];

                    if (candidate && candidate.content?.parts?.[0]?.text) {
                        return candidate.content.parts[0].text;
                    } else {
                        const finishReason = candidate?.finishReason;
                        let errorMessage = "La risposta dell'API non contiene testo.";
                        if (finishReason) {
                           errorMessage = `Generazione interrotta per motivo: ${finishReason}.`;
                        }
                        throw new Error(errorMessage);
                    }
                } catch (error) {
                    if (error.name === 'AbortError') {
                        console.log('Gemini API call aborted.');
                        return null;
                    }
                    showMessage(`Errore Gemini: ${error.message}`, true);
                    if (containerElement) containerElement.innerHTML = `<p class="text-red-500">Errore durante la generazione della risposta AI.</p>`;
                    return null;
                }
            }
            
            async function getGeminiAnalysisForPlayer() {
                geminiLoading.classList.remove('hidden');
                geminiAnalysisResult.innerHTML = '';
            
                const player = getPlayer(currentlyViewingPlayerId);
                const startDate = historyStartDateInput.value;
                const endDate = historyEndDateInput.value;
                const stats = getPlayerStatsForPeriod(currentlyViewingPlayerId, startDate, endDate);
            
                if (stats.matchesPlayed < 1) {
                    geminiAnalysisResult.innerHTML = "Non ci sono abbastanza dati in questo periodo per un'analisi del coach.";
                    geminiLoading.classList.add('hidden');
                    return;
                }
            
                let prompt = `Sei un coach di calcio balilla esigente ma giusto. Il tuo compito √® analizzare la performance del giocatore ${player.name} nel periodo dal ${new Date(startDate).toLocaleDateString('it-IT')} al ${new Date(endDate).toLocaleDateString('it-IT')} e dargli un feedback diretto, come se stessi parlando con lui. Sii buono quando serve, ma non esitare a essere critico e a spronarlo se i dati lo suggeriscono. Concludi sempre con un consiglio pratico per migliorare. Scrivi un paragrafo conciso.

Dati del giocatore nel periodo:
- Partite giocate: ${stats.matchesPlayed}
- Percentuale di vittorie: ${stats.winRate.toFixed(1)}%
- Variazione ELO: ${stats.eloChange >= 0 ? '+' : ''}${stats.eloChange.toFixed(0)}
- Tasso di vittoria in attacco: ${stats.attackWinRate > 0 ? stats.attackWinRate.toFixed(1) + '%' : 'N/A'}
- Tasso di vittoria in difesa: ${stats.defenseWinRate > 0 ? stats.defenseWinRate.toFixed(1) + '%' : 'N/A'}
- Ruolo migliore (basato su win-rate): ${stats.bestRole}`;
            
                if(stats.bestTeammate) {
                    prompt += `\n- Migliore sinergia con: ${stats.bestTeammate.name} (${stats.bestTeammate.winRate.toFixed(1)}% di vittorie in ${stats.bestTeammate.matches} partite)`
                }
            
                const text = await callGeminiAPI(prompt, geminiAnalysisResult);
                if (text) {
                    geminiAnalysisResult.innerHTML = text.replace(/\n/g, '<br>');
                }
                geminiLoading.classList.add('hidden');
            }
            
            async function getGeminiAnalysisForLeaderboard(filteredPlayers, isOverall) {
                if(filteredPlayers.length === 0) {
                    leaderboardCommentaryContainer.classList.add('hidden');
                    return;
                }
                leaderboardCommentaryContainer.classList.remove('hidden');
                leaderboardCommentaryResult.innerHTML = `<p class="animate-pulse">Il critico sta affilando la penna...</p>`;
                
                const startDate = leaderboardStartDate.value;
                const endDate = leaderboardEndDate.value;

                const topPlayersSummary = filteredPlayers.slice(0, 5).map((p, index) => `${index + 1}. ${p.name} (ELO: ${p.elo})`).join('\n');
                
                let timeFrame;
                if(isOverall) {
                    timeFrame = "la classifica generale di tutti i tempi."
                } else {
                    timeFrame = `la classifica per il periodo dal ${new Date(startDate).toLocaleDateString('it-IT')} al ${new Date(endDate).toLocaleDateString('it-IT')}.`
                }

                const prompt = `Sei un critico sportivo di calcio sagace e con un occhio per il dettaglio. Analizza ${timeFrame} La classifica attuale (top 5) √®:\n${topPlayersSummary}\n\nScrivi un breve commento (2-3 frasi) in stile giornalistico, evidenziando chi sta dominando, eventuali sorprese o chi sta deludendo. Usa un linguaggio evocativo e da cronaca sportiva.`;
                
                const text = await callGeminiAPI(prompt, leaderboardCommentaryResult);
                if (text) {
                    leaderboardCommentaryResult.innerHTML = text.replace(/\n/g, '<br>');
                }
            }
            
            async function generateDualMatchCommentaries(matchId) {
                const match = matches.find(m => m.id === matchId);
                if (!match) return;

                const teamAPlayers = { attack: getPlayer(match.teamA.attack), defense: getPlayer(match.teamA.defense) };
                const teamBPlayers = { attack: getPlayer(match.teamB.attack), defense: getPlayer(match.teamB.defense) };
                
                // --- Prompt per il Critico ---
                let promptCritic = `Sei un critico sportivo di calcio. Commenta la seguente partita di calcio balilla, terminata in data ${new Date(match.date).toLocaleDateString('it-IT')}. Sii incisivo e professionale.

Dettagli Partita:
- Squadra Blu: Attacco ${teamAPlayers.attack.name}, Difesa ${teamAPlayers.defense.name}
- Squadra Rossa: Attacco ${teamBPlayers.attack.name}, Difesa ${teamBPlayers.defense.name}
- Risultato Finale: Blu ${match.scoreA} - ${match.scoreB} Rossa
- Vincitore: Squadra ${match.winner === 'A' ? 'Blu' : 'Rossa'}`;

                if (match.scoreA === null || match.scoreB === null) {
                    promptCritic += "\nNota: Il punteggio dettagliato non √® stato registrato, basa il commento solo sulla performance ELO e sulla reputazione dei giocatori.";
                }
                promptCritic += "\nScrivi un breve paragrafo di commento sulla partita.";
                
                const criticText = await callGeminiAPI(promptCritic);
                if (criticText) {
                    match.commentaries.critic = criticText;
                } else {
                    match.commentaries.critic = "Generazione commento del critico fallita.";
                }
                
                // --- Prompt per il Coach ---
                let promptCoach = `Sei un coach di calcio balilla. Analizza la performance di ogni singolo giocatore nella partita appena conclusa. Fornisci un breve feedback (una frase per giocatore) su ${teamAPlayers.attack.name}, ${teamAPlayers.defense.name}, ${teamBPlayers.attack.name}, e ${teamBPlayers.defense.name}. Sii diretto e costruttivo.

Dettagli Partita:
- Squadra Blu (Vincitrice: ${match.winner === 'A'}): Attacco ${teamAPlayers.attack.name}, Difesa ${teamAPlayers.defense.name}
- Squadra Rossa (Vincitrice: ${match.winner === 'B'}): Attacco ${teamBPlayers.attack.name}, Difesa ${teamBPlayers.defense.name}
- Risultato Finale: Blu ${match.scoreA} - ${match.scoreB} Rossa`;

                const coachText = await callGeminiAPI(promptCoach);
                 if (coachText) {
                    match.commentaries.coach = coachText;
                } else {
                    match.commentaries.coach = "Generazione analisi del coach fallita.";
                }

                showMessage("Commenti AI generati!", false);
                saveAndRender(); // Save after both are done
            }


            async function generatePreMatchCommentary() {
                if (preMatchCommentaryAbortController) {
                    preMatchCommentaryAbortController.abort();
                }
                preMatchCommentaryAbortController = new AbortController();
                const signal = preMatchCommentaryAbortController.signal;

                preMatchCommentaryContainer.classList.remove('hidden');
                preMatchCommentaryResult.innerHTML = `<p class="animate-pulse">Il critico sta studiando le formazioni...</p>`;

                const allHistoricalMatches = getAllHistoricalMatches();
                const pA_att = getPlayer(parseInt(teamASelects.attack.value));
                const pA_def = getPlayer(parseInt(teamASelects.defense.value));
                const pB_att = getPlayer(parseInt(teamBSelects.attack.value));
                const pB_def = getPlayer(parseInt(teamBSelects.defense.value));

                const teamA_elo = Math.round((calculateRoleBasedElo(pA_att, 'attack', allHistoricalMatches) + calculateRoleBasedElo(pA_def, 'defense', allHistoricalMatches)) / 2);
                const teamB_elo = Math.round((calculateRoleBasedElo(pB_att, 'attack', allHistoricalMatches) + calculateRoleBasedElo(pB_def, 'defense', allHistoricalMatches)) / 2);

                const prompt = `Sei un critico sportivo di calcio, famoso per le tue analisi pre-partita. Analizza la sfida imminente tra queste due squadre di calcio balilla.

- Squadra Blu: Attacco ${pA_att.name}, Difesa ${pA_def.name}. ELO di squadra calcolato per ruolo: ${teamA_elo}.
- Squadra Rossa: Attacco ${pB_att.name}, Difesa ${pB_def.name}. ELO di squadra calcolato per ruolo: ${teamB_elo}.

Sulla base di questi dati e della forza percepita dei giocatori, scrivi un breve commento pre-partita (2-3 frasi), indicando chi vedi come favorito e perch√©.`;
                
                 const text = await callGeminiAPI(prompt, preMatchCommentaryResult, signal);
                 if (signal.aborted) return;

                 if (text) {
                     preMatchCommentaryResult.innerHTML = text.replace(/\n/g, '<br>');
                 }
            }

            async function getEloExplanation() {
                if (cachedEloExplanation) {
                    eloExplanationContent.innerHTML = cachedEloExplanation;
                    openModal(eloExplanationModal);
                    return;
                }
                
                openModal(eloExplanationModal);

                const prompt = `Spiega in modo semplice e discorsivo, come se stessi parlando a un appassionato, come funziona il calcolo del punteggio ELO per le squadre di calcio balilla in questa applicazione. Includi i seguenti punti:
1.  Il punteggio ELO non √® statico, ma viene calcolato dinamicamente per ogni giocatore in base al suo ruolo (attacco o difesa) in quella partita.
2.  Si analizza lo storico delle partite di un giocatore in un determinato ruolo per stimare la sua forza in quella posizione.
3.  La forza della squadra √® la media degli ELO basati sul ruolo dei due giocatori.
4.  Questo permette di avere una stima pi√π precisa della forza di una squadra, perch√© un giocatore potrebbe essere un fenomeno in attacco ma mediocre in difesa, e il sistema ne tiene conto.
Usa un massimo di 3-4 paragrafi.`;

                const text = await callGeminiAPI(prompt, eloExplanationContent);
                if (text) {
                    cachedEloExplanation = text.replace(/\n/g, '<br><br>');
                    eloExplanationContent.innerHTML = cachedEloExplanation;
                }
            }


            function renderPlayerMatchHistory() {
                const player = getPlayer(currentlyViewingPlayerId);
                const startDate = historyStartDateInput.value;
                const endDate = historyEndDateInput.value;
                const allHistoricalMatches = getAllHistoricalMatches();
                const playerMatches = allHistoricalMatches.filter(m => (m.teamA.attack === player.id || m.teamA.defense === player.id || m.teamB.attack === player.id || m.teamB.defense === player.id) && m.date >= startDate && m.date <= endDate);
                playerMatches.sort((a,b) => playerMatchSortSelect.value === 'date_desc' ? new Date(b.date) - new Date(a.date) : new Date(a.date) - new Date(b.date));

                playerMatchHistoryContainer.innerHTML = playerMatches.length ? '' : `<p class="text-center text-gray-500 py-4">Nessuna partita in questo periodo.</p>`;
                playerMatches.forEach(match => {
                    const teamAPlayers = { attack: getPlayer(match.teamA.attack), defense: getPlayer(match.teamA.defense) };
                    const teamBPlayers = { attack: getPlayer(match.teamB.attack), defense: getPlayer(match.teamB.defense) };
                    const isPlayerInTeamA = match.teamA.attack === player.id || match.teamA.defense === player.id;
                    const didPlayerWin = (isPlayerInTeamA && match.winner === 'A') || (!isPlayerInTeamA && match.winner === 'B');
                    const resultClass = didPlayerWin ? 'bg-green-100 text-green-800' : 'bg-red-100 text-red-800';

                    const isEloActive = !match.isTournament || (tournaments.find(t => t.name === match.tournamentName)?.affectsElo ?? false);
                    const eloChange = isEloActive && match.eloChange != null ? Math.round(didPlayerWin ? match.eloChange : -match.eloChange) : 0;
                    const resultText = didPlayerWin ? 'Vittoria' : 'Sconfitta';
                    const matchIcon = match.isTournament ? 'üèÜ' : 'ü§ù';

                    const matchDiv = document.createElement('div');
                    matchDiv.className = 'border border-gray-200 rounded-lg';
                    matchDiv.innerHTML = `
                        <button class="player-match-accordion-header w-full p-3 text-left bg-gray-50 hover:bg-gray-100 rounded-t-lg">
                            <div class="flex justify-between items-center flex-wrap gap-2">
                                <div>
                                    <span class="font-bold text-gray-800">${new Date(match.date).toLocaleDateString('it-IT')} ${matchIcon}</span>
                                    <span class="text-sm text-gray-500 ml-2">${teamAPlayers.attack.name} & ${teamAPlayers.defense.name} vs ${teamBPlayers.attack.name} & ${teamBPlayers.defense.name}</span>
                                </div>
                                <div class="flex items-center gap-2">
                                     <button class="btn btn-secondary text-xs px-2 py-1 rounded generate-commentary-btn" data-match-id="${match.id}" ${match.isTournament ? 'style="display:none;"' : ''}>Analisi AI</button>
                                     <span class="font-bold text-sm px-2 py-1 rounded-full ${resultClass}">${resultText} ${isEloActive ? `(${eloChange >= 0 ? '+' : ''}${eloChange} ELO)`: ''}</span>
                                     <svg class="w-5 h-5 shrink-0 transition-transform duration-300" fill="none" viewBox="0 0 24 24" stroke="currentColor"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M19 9l-7 7-7-7" /></svg>
                                </div>
                            </div>
                        </button>
                        <div class="player-match-accordion-content hidden p-4 border-t border-gray-200 bg-white rounded-b-lg space-y-4">
                            <div class="grid grid-cols-1 md:grid-cols-2 gap-4">
                                <div>
                                    <h4 class="font-semibold text-gray-800 text-sm mb-2 flex items-center gap-2"><span class="text-base">üéôÔ∏è</span> La cronaca del critico</h4>
                                    <p class="text-sm italic text-gray-600 border-l-2 pl-2 border-gray-200 min-h-[40px]">${match.commentaries?.critic || "Nessun commento generato."}</p>
                                </div>
                                <div>
                                    <h4 class="font-semibold text-gray-800 text-sm mb-2 flex items-center gap-2"><span class="text-base">ü§ñ</span> L'analisi del coach</h4>
                                    <p class="text-sm italic text-gray-600 border-l-2 pl-2 border-gray-200 min-h-[40px]">${match.commentaries?.coach || "Nessun commento generato."}</p>
                                </div>
                            </div>
                            <div class="grid grid-cols-1 md:grid-cols-2 gap-4 pt-4 border-t">
                                <div class="team-blue-color">
                                    <h4 class="font-bold border-b pb-1 mb-2">Squadra Blu (ELO Medio: ${match.teamA_elos ? Math.round((match.teamA_elos.attack + match.teamA_elos.defense) / 2) : 'N/A'})</h4>
                                    <p>‚öîÔ∏è ${teamAPlayers.attack.name}: <span class="font-semibold">${match.teamA_elos ? match.teamA_elos.attack : 'N/A'}</span></p>
                                    <p>üõ°Ô∏è ${teamAPlayers.defense.name}: <span class="font-semibold">${match.teamA_elos ? match.teamA_elos.defense : 'N/A'}</span></p>
                                </div>
                                <div class="team-red-color">
                                    <h4 class="font-bold border-b pb-1 mb-2">Squadra Rossa (ELO Medio: ${match.teamB_elos ? Math.round((match.teamB_elos.attack + match.teamB_elos.defense) / 2) : 'N/A'})</h4>
                                    <p>‚öîÔ∏è ${teamBPlayers.attack.name}: <span class="font-semibold">${match.teamB_elos ? match.teamB_elos.attack : 'N/A'}</span></p>
                                    <p>üõ°Ô∏è ${teamBPlayers.defense.name}: <span class="font-semibold">${match.teamB_elos ? match.teamB_elos.defense : 'N/A'}</span></p>
                                </div>
                            </div>
                        </div>`;
                    playerMatchHistoryContainer.appendChild(matchDiv);
                });
            }

            function renderPlayerTournaments() {
                 const player = getPlayer(currentlyViewingPlayerId);
                 const playerTournaments = tournaments.filter(t => t.teams.some(team => team.player1Id === player.id || team.player2Id === player.id));

                 playerTournamentsContainer.innerHTML = playerTournaments.length ? '' : `<p class="text-center text-gray-500 py-4">Nessun torneo disputato.</p>`;
                 playerTournaments.forEach(t => {
                     const playerTeam = t.teams.find(team => team.player1Id === player.id || team.player2Id === player.id);
                     const partner = getPlayer(playerTeam.player1Id === player.id ? playerTeam.player2Id : playerTeam.player1Id);

                     let placement = "In Corso";
                     if(t.status === 'completed') {
                         if (t.winnerTeamId === playerTeam.id) {
                            placement = "üèÜ Vincitore";
                         } else {
                            // Find which round the player was eliminated in
                            let roundLost = -1;
                             for(let i = 0; i < t.rounds.length; i++) {
                                 const match = t.rounds[i].find(m => m.teamAId === playerTeam.id || m.teamBId === playerTeam.id);
                                 if (match && match.winnerTeamId && match.winnerTeamId !== playerTeam.id) {
                                     roundLost = i;
                                     break;
                                 }
                             }
                             if(roundLost === 0) placement = `Eliminato al 1¬∞ Turno`;
                             else if(roundLost === 1 && t.teams.length > 4) placement = `Eliminato ai Quarti`;
                             else if((roundLost === 2 && t.teams.length > 8) || (roundLost === 1 && t.teams.length <= 4)) placement = `Eliminato in Semifinale`;
                             else if (roundLost !== -1) placement = `Finalista`;
                         }
                     }

                     const card = document.createElement('div');
                     card.className = "p-4 bg-gray-50 rounded-lg border cursor-pointer hover:border-blue-400";
                     card.innerHTML = `
                        <div class="flex justify-between items-center">
                            <div>
                                <h4 class="font-bold text-lg text-gray-800">${t.name}</h4>
                                <p class="text-sm text-gray-600">In squadra con: <span class="font-semibold">${partner.name}</span></p>
                            </div>
                            <div class="text-right">
                                <p class="font-bold text-lg ${placement === 'üèÜ Vincitore' ? 'text-yellow-500' : 'text-gray-700'}">${placement}</p>
                                <p class="text-sm text-gray-500">${new Date(t.date).toLocaleDateString('it-IT')}</p>
                            </div>
                        </div>
                     `;
                     card.addEventListener('click', () => openTournamentViewModal(t.id));
                     playerTournamentsContainer.appendChild(card);
                 })
            }

            function handleComparison() {
                const selectedPlayerIds = Array.from(comparisonPlayerList.querySelectorAll('input:checked')).map(cb => parseInt(cb.value));
                const startDate = comparisonStartDateInput.value, endDate = comparisonEndDateInput.value;
                if (!startDate || !endDate) return showMessage("Seleziona un intervallo di date.", true);

                if (comparisonMode === 'general') handleGeneralComparison(selectedPlayerIds, startDate, endDate);
                if (comparisonMode === 'roles') handleRoleComparison(selectedPlayerIds, startDate, endDate);
                if (comparisonMode === 'synergy') handleSynergyComparison(selectedPlayerIds, startDate, endDate);
            }

            function handleGeneralComparison(playerIds, startDate, endDate) {
                if (playerIds.length < 2) return showMessage("Seleziona almeno due giocatori.", true);

                const selectedPlayers = getPlayers(playerIds);
                const allDates = new Set();
                selectedPlayers.forEach(p => { p.history.slice(1).forEach(h => {
                    const d = new Date(h.date);
                    if (d >= new Date(startDate) && d <= new Date(endDate)) allDates.add(h.date);
                }); });
                const sortedDates = Array.from(allDates).sort();

                const datasets = selectedPlayers.map((player, index) => {
                    let lastElo = player.history[0].elo;
                    const data = sortedDates.map(date => {
                        const historyOnDate = player.history.filter(h => h.date <= date);
                        return historyOnDate.length > 0 ? historyOnDate[historyOnDate.length - 1].elo : lastElo;
                    });
                    return { label: player.name, data: data, borderColor: CHART_COLORS[index % CHART_COLORS.length], backgroundColor: 'transparent', tension: 0.1 };
                });

                comparisonModalTitle.textContent = "Confronto Generale ELO";
                comparisonModalContent.innerHTML = `<canvas id="eloComparisonChart"></canvas>`;
                renderComparisonChart('line', sortedDates.map(d => new Date(d).toLocaleDateString('it-IT')), datasets);
                openModal(comparisonModal);
            }

            function handleRoleComparison(playerIds, startDate, endDate) {
                if (playerIds.length < 1) return showMessage("Seleziona almeno un giocatore.", true);

                const selectedRole = rolesSelect.value;
                const selectedPlayers = getPlayers(playerIds);
                const allHistoricalMatches = getAllHistoricalMatches();

                const tableRows = selectedPlayers.map(player => {
                    const roleMatches = allHistoricalMatches.filter(m => ((m.teamA[selectedRole] === player.id || m.teamB[selectedRole] === player.id)) && m.date >= startDate && m.date <= endDate);
                    const wins = roleMatches.filter(m => (m.teamA[selectedRole] === player.id && m.winner === 'A') || (m.teamB[selectedRole] === player.id && m.winner === 'B')).length;
                    const winRate = roleMatches.length > 0 ? (wins / roleMatches.length) * 100 : 0;

                    const eloChanges = roleMatches.map(m => {
                        const historyIndex = player.history.findIndex(h => h.date === m.date);
                        if (historyIndex > 0) return player.history[historyIndex].elo - player.history[historyIndex - 1].elo;
                        return 0;
                    }).filter(c => c !== 0);
                    const avgEloChange = eloChanges.length > 0 ? eloChanges.reduce((a,b) => a+b, 0) / eloChanges.length : 0;

                    return `
                        <tr class="border-b">
                            <td class="p-2 font-semibold">${player.name}</td>
                            <td class="p-2 text-center">${roleMatches.length}</td>
                            <td class="p-2 text-center font-bold ${winRate >= 50 ? 'text-green-600' : 'text-red-600'}">${winRate.toFixed(1)}%</td>
                            <td class="p-2 text-center font-bold ${avgEloChange >= 0 ? 'text-green-600' : 'text-red-600'}">${avgEloChange >= 0 ? '+' : ''}${avgEloChange.toFixed(1)}</td>
                        </tr>`;
                }).join('');

                comparisonModalTitle.textContent = `Analisi Ruolo: ${selectedRole === 'attack' ? '‚öîÔ∏è Attacco' : 'üõ°Ô∏è Difesa'}`;
                comparisonModalContent.innerHTML = `
                    <p class="text-sm text-gray-600 mb-4">Confronto delle performance dei giocatori quando schierati nel ruolo selezionato.</p>
                    <table class="w-full text-sm">
                        <thead><tr class="border-b"><th class="p-2 text-left">Giocatore</th><th class="p-2">Partite</th><th class="p-2">% Vittorie</th><th class="p-2">ELO Medio/Partita</th></tr></thead>
                        <tbody>${tableRows}</tbody>
                    </table>`;
                openModal(comparisonModal);
            }

            function handleSynergyComparison(playerIds, startDate, endDate) {
                const pivotPlayerId = parseInt(synergyPivotPlayer.value);
                if (!pivotPlayerId) return showMessage("Seleziona un giocatore 'pilastro' per l'analisi.", true);
                if (playerIds.length < 1) return showMessage("Seleziona almeno un compagno da confrontare.", true);

                const pivotPlayer = getPlayer(pivotPlayerId);
                const partners = getPlayers(playerIds.filter(id => id !== pivotPlayerId));
                const allHistoricalMatches = getAllHistoricalMatches();

                const synergyData = partners.map(partner => {
                    const duoMatches = allHistoricalMatches.filter(m => {
                        const teamAids = Object.values(m.teamA);
                        const teamBids = Object.values(m.teamB);
                        return ((teamAids.includes(pivotPlayer.id) && teamAids.includes(partner.id)) || (teamBids.includes(pivotPlayer.id) && teamBids.includes(partner.id))) && m.date >= startDate && m.date <= endDate;
                    });

                    const scenario1 = { matches: 0, wins: 0, teamElos: [] }; // Pivot Attack, Partner Defense
                    const scenario2 = { matches: 0, wins: 0, teamElos: [] }; // Pivot Defense, Partner Attack

                    duoMatches.forEach(m => {
                        const inTeamA = Object.values(m.teamA).includes(pivotPlayer.id);
                        const team = inTeamA ? m.teamA : m.teamB;
                        const elos = inTeamA ? m.teamA_elos : m.teamB_elos;
                        const won = (inTeamA && m.winner === 'A') || (!inTeamA && m.winner === 'B');

                        if (team.attack === pivotPlayer.id && team.defense === partner.id) {
                            scenario1.matches++;
                            if(won) scenario1.wins++;
                            if(elos) scenario1.teamElos.push((elos.attack + elos.defense) / 2);
                        } else if (team.defense === pivotPlayer.id && team.attack === partner.id) {
                            scenario2.matches++;
                            if(won) scenario2.wins++;
                            if(elos) scenario2.teamElos.push((elos.attack + elos.defense) / 2);
                        }
                    });

                    return {
                        name: partner.name,
                        scenario1: { ...scenario1, winRate: scenario1.matches > 0 ? (scenario1.wins/scenario1.matches)*100 : 0, medianElo: calculateMedian(scenario1.teamElos) },
                        scenario2: { ...scenario2, winRate: scenario2.matches > 0 ? (scenario2.wins/scenario2.matches)*100 : 0, medianElo: calculateMedian(scenario2.teamElos) }
                    };
                }).sort((a,b) => Math.max(b.scenario1.medianElo, b.scenario2.medianElo) - Math.max(a.scenario1.medianElo, a.scenario2.medianElo));

                comparisonModalTitle.textContent = `Analisi Sinergie con ${pivotPlayer.name}`;

                if(synergyData.every(d => d.scenario1.matches === 0 && d.scenario2.matches === 0)){
                     comparisonModalContent.innerHTML = `<p class="text-center text-gray-500 py-4">Nessuna partita giocata con i compagni selezionati in questo periodo.</p>`;
                } else {
                    comparisonModalContent.innerHTML = synergyData.map(data => {
                        return `
                        <div class="p-4 border rounded-lg mb-4">
                            <h3 class="font-bold text-lg text-gray-800">${data.name}</h3>
                            <div class="grid grid-cols-1 md:grid-cols-2 gap-4 mt-2">
                                <div class="p-3 rounded ${data.scenario1.matches > 0 ? 'bg-gray-100' : 'bg-gray-50 text-gray-400'}">
                                    <p class="font-semibold">Tu ‚öîÔ∏è & Lui/Lei üõ°Ô∏è</p>
                                    ${data.scenario1.matches > 0 ? `
                                    <p class="text-sm mt-1">Partite: <span class="font-semibold">${data.scenario1.matches}</span></p>
                                    <p class="text-sm">Vittorie: <span class="font-semibold">${data.scenario1.winRate.toFixed(0)}%</span></p>
                                    <p class="text-sm">ELO Mediano Squadra: <span class="font-semibold">${Math.round(data.scenario1.medianElo)}</span></p>
                                    ` : '<p class="text-sm mt-1">Nessuna partita</p>'}
                                </div>
                                <div class="p-3 rounded ${data.scenario2.matches > 0 ? 'bg-gray-100' : 'bg-gray-50 text-gray-400'}">
                                    <p class="font-semibold">Tu üõ°Ô∏è & Lui/Lei ‚öîÔ∏è</p>
                                     ${data.scenario2.matches > 0 ? `
                                    <p class="text-sm mt-1">Partite: <span class="font-semibold">${data.scenario2.matches}</span></p>
                                    <p class="text-sm">Vittorie: <span class="font-semibold">${data.scenario2.winRate.toFixed(0)}%</span></p>
                                    <p class="text-sm">ELO Mediano Squadra: <span class="font-semibold">${Math.round(data.scenario2.medianElo)}</span></p>
                                    ` : '<p class="text-sm mt-1">Nessuna partita</p>'}
                                </div>
                            </div>
                        </div>
                        `
                    }).join('');
                }
                openModal(comparisonModal);
            }

            function renderComparisonChart(type, labels, datasets) {
                if (comparisonChart) comparisonChart.destroy();
                const container = document.getElementById('eloComparisonChart');
                if(!container) return;
                comparisonChart = new Chart(container.getContext('2d'), {
                    type: type,
                    data: { labels, datasets },
                    options: { responsive: true, plugins: { legend: { position: 'top', display: datasets.length > 1 } } }
                });
            }

            // --- Eliminazione Multipla ---
            function handleBulkDeletePreview() {
                const startDate = bulkDeleteStartDateInput.value, endDate = bulkDeleteEndDateInput.value;
                if (!startDate || !endDate) return showMessage("Seleziona un intervallo di date.", true);
                const matchesInRange = matches.filter(m => m.date >= startDate && m.date <= endDate);
                if (matchesInRange.length === 0) return showMessage("Nessuna partita trovata.", false);

                matchesToDeleteIds = matchesInRange.map(m => m.id);
                bulkDeleteSummaryText.textContent = `Stai per eliminare ${matchesInRange.length} partite. L'azione √® irreversibile.`;
                confirmBulkDeleteBtn.textContent = `Conferma Eliminazione (${matchesToDeleteIds.length} partite)`;
                renderMatches(bulkDeleteMatchList, matchesInRange);
                openModal(confirmBulkDeleteModal);
            }

            // --- Accordion ---
            function setupAccordions() {
                document.querySelectorAll('.accordion-header').forEach(button => {
                    button.addEventListener('click', () => {
                        const content = button.nextElementSibling;
                        const icon = button.querySelector('svg');
                        const isOpening = content.classList.contains('hidden');
                        content.classList.toggle('hidden');
                        icon.classList.toggle('rotate-180');
                        
                        if(isOpening && button.querySelector('h2').textContent.includes('Classifica Giocatori')) {
                            // Trigger analysis if opening and on "Overall" tab
                            const isOverall = document.getElementById('rankOverall').checked;
                            if (isOverall) {
                                renderPlayers();
                            }
                        }
                    });
                });

                matchHistoryContainer.addEventListener('click', e => {
                    const header = e.target.closest('.player-match-accordion-header');
                    if (header) {
                        header.nextElementSibling.classList.toggle('hidden');
                        header.querySelector('svg').classList.toggle('rotate-180');
                    }
                });

                playerMatchHistoryContainer.addEventListener('click', e => {
                    const header = e.target.closest('.player-match-accordion-header');
                    if (header) {
                        header.nextElementSibling.classList.toggle('hidden');
                        header.querySelector('svg').classList.toggle('rotate-180');
                    }
                });
            }

            // --- Import/Export e Persistenza ---
            async function linkFile() {
                try {
                    fileHandle = await window.showSaveFilePicker({
                        suggestedName: 'dati.json',
                        types: [{ description: 'JSON Files', accept: { 'application/json': ['.json'] } }]
                    });
                    const file = await fileHandle.getFile();
                    const contents = await file.text();
                    if(contents) { // If file has content, load it
                        loadData(JSON.parse(contents));
                        showMessage("File collegato e dati caricati!");
                    } else { // If new file, save current state to it
                        await saveToFile();
                        showMessage("Nuovo file collegato e dati iniziali salvati!");
                    }
                } catch (err) {
                    if (err.name !== 'AbortError') {
                        console.error(err);
                        showMessage("Errore nel collegamento del file.", true);
                    }
                }
            }

            async function saveToFile() {
                if (!fileHandle) return;
                try {
                    const writable = await fileHandle.createWritable();
                    await writable.write(JSON.stringify({ players, matches, tournaments }));
                    await writable.close();
                } catch (err) {
                    console.error("Errore salvataggio su file:", err);
                    showMessage("Errore nel salvataggio su file. I dati sono salvati localmente.", true);
                    fileHandle = null; // Reset handle if permission is lost
                }
            }

            function loadData(data) {
                if (!data.players || !data.matches) throw new Error("File non valido.");

                // Data migration for commentaries
                data.matches.forEach(m => {
                    if (Array.isArray(m.teamA)) {
                        m.teamA = { attack: m.teamA[0], defense: m.teamA[1] };
                        m.teamB = { attack: m.teamB[0], defense: m.teamB[1] };
                    }
                    if (m.commentary && typeof m.commentary === 'string') {
                        m.commentaries = { critic: m.commentary, coach: null };
                        delete m.commentary;
                    } else if (!m.commentaries) {
                        m.commentaries = { critic: null, coach: null };
                    }
                });
                
                players = data.players || [];
                matches = data.matches || [];
                tournaments = data.tournaments || [];
                recalculateAllElos();
                saveAndRender();
            }

            function exportData() {
                const dataString = JSON.stringify({ players, matches, tournaments });
                const blob = new Blob([dataString], { type: 'application/json' });
                const a = document.createElement('a');
                a.href = URL.createObjectURL(blob);
                a.download = `foosball-lab-backup_${new Date().toISOString().split('T')[0]}.json`;
                a.click();
                URL.revokeObjectURL(a.href);
                showMessage("Backup esportato!");
            }

            function importData(event) {
                const file = event.target.files[0];
                if (!file) return;
                const reader = new FileReader();
                reader.onload = e => {
                    try {
                        loadData(JSON.parse(e.target.result));
                        showMessage("Backup importato con successo!");
                    } catch (err) { showMessage(`Errore importazione: ${err.message}`, true); }
                };
                reader.readAsText(file);
                importFileInput.value = '';
            }

            async function saveAndRender() {
                localStorage.setItem('foosballEloTracker', JSON.stringify({ players, matches, tournaments }));
                await saveToFile();
                render();
            }

            function loadFromStorage() {
                const storedState = localStorage.getItem('foosballEloTracker');
                if (storedState) {
                   loadData(JSON.parse(storedState));
                }
                 // Gestione API Key
                const storedApiKey = localStorage.getItem('geminiApiKey');
                if (storedApiKey) {
                    try {
                        geminiApiKeyInput.value = decryptKey(storedApiKey);
                    } catch (e) {
                        localStorage.removeItem('geminiApiKey'); // Rimuovi se corrotta
                    }
                } else {
                    // Imposta e salva la chiave di default se non ce n'√® una
                    const defaultKey = "YOUR_DEFAULT_API_KEY"; // Inserisci una chiave predefinita se necessario
                    if(defaultKey !== "YOUR_DEFAULT_API_KEY"){
                        geminiApiKeyInput.value = defaultKey;
                        localStorage.setItem('geminiApiKey', encryptKey(defaultKey));
                    }
                }
            }

            // --- Assistente Pre-Partita ---
            function showPreMatchAssistant() {
                if (localStorage.getItem('hideWizard') === 'true' || players.length < 4) {
                    closeModal(preMatchAssistantModal);
                    return;
                }
                openModal(preMatchAssistantModal);

                wizardActions.innerHTML = ''; // Clear previous actions

                // 1. Rivincita
                if (matches.length > 0) {
                    const lastMatch = matches[matches.length - 1];
                    const teamAPlayers = { attack: getPlayer(lastMatch.teamA.attack), defense: getPlayer(lastMatch.teamA.defense) };
                    const teamBPlayers = { attack: getPlayer(lastMatch.teamB.attack), defense: getPlayer(lastMatch.teamB.defense) };

                    if(Object.values(teamAPlayers).every(p => p) && Object.values(teamBPlayers).every(p => p)) {
                        const actionCard = document.createElement('button');
                        actionCard.className = 'wizard-action-card w-full';
                        actionCard.innerHTML = `
                            <p class="font-bold text-lg">üî• Rivincita?</p>
                            <p class="text-sm text-gray-600">Ripeti l'ultima partita: ${teamAPlayers.attack.name} & ${teamAPlayers.defense.name} vs ${teamBPlayers.attack.name} & ${teamBPlayers.defense.name}</p>
                        `;
                        actionCard.addEventListener('click', () => {
                            teamASelects.attack.value = lastMatch.teamA.attack;
                            teamASelects.defense.value = lastMatch.teamA.defense;
                            teamBSelects.attack.value = lastMatch.teamB.attack;
                            teamBSelects.defense.value = lastMatch.teamB.defense;
                            updateTeamEloDisplays();
                            closePreMatchAssistant();
                        });
                        wizardActions.appendChild(actionCard);
                    }
                }

                // 2. Sfida del Giorno
                if (players.length >= 4) {
                    const sortedPlayers = [...players].sort((a,b) => b.elo - a.elo);
                    const p1 = sortedPlayers[0], p2 = sortedPlayers[1], p3 = sortedPlayers[2], p4 = sortedPlayers[3];

                    const actionCard = document.createElement('button');
                    actionCard.className = 'wizard-action-card w-full';
                    actionCard.innerHTML = `
                        <p class="font-bold text-lg">üèÜ Sfida al Vertice</p>
                        <p class="text-sm text-gray-600">Partita equilibrata tra i top 4: ${p1.name} & ${p4.name} vs ${p2.name} & ${p3.name}</p>
                    `;
                    actionCard.addEventListener('click', () => {
                        teamASelects.attack.value = p1.id;
                        teamASelects.defense.value = p4.id;
                        teamBSelects.attack.value = p2.id;
                        teamBSelects.defense.value = p3.id;
                        updateTeamEloDisplays();
                        closePreMatchAssistant();
                    });
                    wizardActions.appendChild(actionCard);
                }

                // 3. Altre Azioni
                const wizardRegister = document.createElement('button');
                wizardRegister.id = 'wizardRegister';
                wizardRegister.className = 'wizard-action-card w-full';
                wizardRegister.innerHTML = `
                    <p class="font-bold text-lg">‚úçÔ∏è Registra una Partita Manualmente</p>
                    <p class="text-sm text-gray-600">Scegli tu i giocatori e i ruoli per la prossima sfida.</p>
                `;
                wizardActions.appendChild(wizardRegister);

                const wizardLab = document.createElement('button');
                wizardLab.id = 'wizardLab';
                wizardLab.className = 'wizard-action-card w-full';
                wizardLab.innerHTML = `
                    <p class="font-bold text-lg">üî¨ Vai al Laboratorio</p>
                    <p class="text-sm text-gray-600">Analizza le classifiche, le sinergie e gli storici.</p>
                `;
                wizardActions.appendChild(wizardLab);

                document.getElementById('wizardRegister').addEventListener('click', closePreMatchAssistant);
                document.getElementById('wizardLab').addEventListener('click', closePreMatchAssistant);
            }

            function closePreMatchAssistant() {
                if(hideWizardCheckbox.checked) {
                    localStorage.setItem('hideWizard', 'true');
                }
                closeModal(preMatchAssistantModal);
            }

            // --- Logica Tornei ---

            function openTournamentCreationModal() {
                tourneyCreationState = {
                    name: '',
                    date: new Date().toISOString().split('T')[0],
                    teamsCount: 8,
                    affectsElo: false,
                    selectedPlayers: [],
                    teams: [],
                    teamCreationMode: 'balanced'
                };
                tournamentDateInput.value = tourneyCreationState.date;
                // Reset to step 1
                tourneyStep1.classList.remove('hidden');
                tourneyStep2.classList.add('hidden');
                tourneyStep3.classList.add('hidden');
                openModal(tournamentCreationModal);
            }

            function setupTournamentCreationWizard() {
                // Step 1 -> Step 2
                tourneyNextToStep2.addEventListener('click', () => {
                    tourneyCreationState.name = tournamentNameInput.value.trim();
                    tourneyCreationState.date = tournamentDateInput.value;
                    tourneyCreationState.teamsCount = parseInt(tournamentTeamsNumber.value);
                    tourneyCreationState.affectsElo = tournamentAffectsElo.checked;

                    if (!tourneyCreationState.name || !tourneyCreationState.date) {
                        return showMessage("Per favore, compila nome e data del torneo.", true);
                    }

                    const requiredPlayers = tourneyCreationState.teamsCount * 2;
                    document.getElementById('requiredPlayerCount').textContent = requiredPlayers;

                    renderTournamentPlayerSelection();

                    tourneyStep1.classList.add('hidden');
                    tourneyStep2.classList.remove('hidden');
                });

                // Step 2 -> Step 1
                 tourneyBackToStep1.addEventListener('click', () => {
                    tourneyStep2.classList.add('hidden');
                    tourneyStep1.classList.remove('hidden');
                });

                // Step 2 -> Step 3
                tourneyNextToStep3.addEventListener('click', () => {
                    tourneyCreationState.selectedPlayers = Array.from(tournamentPlayerSelection.querySelectorAll('input:checked')).map(cb => parseInt(cb.value));
                    renderTeamCreationStep();
                    tourneyStep2.classList.add('hidden');
                    tourneyStep3.classList.remove('hidden');
                });

                // Step 3 -> Step 2
                tourneyBackToStep2.addEventListener('click', () => {
                    tourneyStep3.classList.add('hidden');
                    tourneyStep2.classList.remove('hidden');
                });

                 createTournamentBtn.addEventListener('click', createTournament);
            }

            function renderTournamentPlayerSelection() {
                tournamentPlayerSelection.innerHTML = '';
                const sortedPlayers = [...players].sort((a,b) => a.name.localeCompare(b.name));
                sortedPlayers.forEach(player => {
                    tournamentPlayerSelection.innerHTML += `
                    <label class="flex items-center space-x-2 cursor-pointer p-1 rounded hover:bg-gray-100">
                        <input type="checkbox" value="${player.id}" name="tourneyPlayer" class="rounded border-gray-300 text-[--team-blue] focus:ring-[--team-blue]">
                        <span>${player.name} (${Math.round(player.elo)})</span>
                    </label>`;
                });

                // Add event listener to enable/disable next button
                tournamentPlayerSelection.addEventListener('change', () => {
                    const selectedCount = tournamentPlayerSelection.querySelectorAll('input:checked').length;
                    const requiredCount = tourneyCreationState.teamsCount * 2;
                    document.getElementById('requiredPlayerCount').textContent = `${requiredCount} (selezionati: ${selectedCount})`;
                    tourneyNextToStep3.disabled = selectedCount !== requiredCount;
                });
            }

            function renderTeamCreationStep() {
                const teamCreationTabs = tourneyStep3.querySelectorAll('.assistant-tab');
                teamCreationTabs.forEach(tab => tab.addEventListener('click', (e) => {
                    teamCreationTabs.forEach(t => t.classList.remove('active'));
                    e.target.classList.add('active');
                    tourneyCreationState.teamCreationMode = e.target.dataset.tab;
                    tourneyBalancedTeams.classList.toggle('hidden', tourneyCreationState.teamCreationMode !== 'balanced');
                    tourneyManualTeams.classList.toggle('hidden', tourneyCreationState.teamCreationMode !== 'manual');
                }));

                const selected = getPlayers(tourneyCreationState.selectedPlayers);
                selected.sort((a,b) => b.elo - a.elo);
                const teams = [];
                for(let i = 0; i < tourneyCreationState.teamsCount; i++) {
                    const p1 = selected[i];
                    const p2 = selected[selected.length - 1 - i];
                    teams.push({ id: i + 1, name: `Squadra ${i+1}`, player1Id: p1.id, player2Id: p2.id });
                }
                tourneyCreationState.teams = teams;

                tourneyBalancedTeams.innerHTML = '<p class="font-semibold text-gray-700 mb-2">Queste sono le squadre bilanciate proposte.</p>';
                teams.forEach(team => {
                    const p1 = getPlayer(team.player1Id);
                    const p2 = getPlayer(team.player2Id);
                    const teamRow = document.createElement('div');
                    teamRow.className = "p-2 bg-gray-50 rounded flex justify-between items-center";
                    teamRow.innerHTML = `
                        <span class="font-bold">${team.name}</span>
                        <span>${p1.name} & ${p2.name}</span>
                        <span class="text-sm font-semibold text-gray-600">ELO Medio: ${Math.round((p1.elo + p2.elo) / 2)}</span>
                    `;
                    tourneyBalancedTeams.appendChild(teamRow);
                });

                let manualHTML = '';
                const playerOptions = tourneyCreationState.selectedPlayers.map(id => {
                    const p = getPlayer(id);
                    return `<option value="${p.id}">${p.name}</option>`;
                }).join('');

                for(let i=0; i < tourneyCreationState.teamsCount; i++) {
                     manualHTML += `
                     <div class="grid grid-cols-3 gap-2 items-center">
                         <span class="font-bold">Squadra ${i+1}</span>
                         <select data-team-idx="${i}" data-player-idx="0">${playerOptions}</select>
                         <select data-team-idx="${i}" data-player-idx="1">${playerOptions}</select>
                     </div>
                     `;
                }
                tourneyManualTeams.innerHTML = manualHTML;
            }

            function createTournament() {
                 if (tourneyCreationState.teamCreationMode === 'manual') {
                    const manualTeams = [];
                    const allSelectedPlayerIds = new Set();
                    let isValid = true;
                    for(let i=0; i < tourneyCreationState.teamsCount; i++) {
                        const p1Id = parseInt(tourneyManualTeams.querySelector(`select[data-team-idx="${i}"][data-player-idx="0"]`).value);
                        const p2Id = parseInt(tourneyManualTeams.querySelector(`select[data-team-idx="${i}"][data-player-idx="1"]`).value);
                        if (p1Id === p2Id) {
                            showMessage(`I giocatori in Squadra ${i+1} devono essere diversi.`, true);
                            isValid = false; break;
                        }
                        if (allSelectedPlayerIds.has(p1Id) || allSelectedPlayerIds.has(p2Id)) {
                             showMessage(`Giocatore duplicato trovato. Ogni giocatore pu√≤ appartenere a una sola squadra.`, true);
                             isValid = false; break;
                        }
                        allSelectedPlayerIds.add(p1Id);
                        allSelectedPlayerIds.add(p2Id);
                        manualTeams.push({ id: i + 1, name: `Squadra ${i+1}`, player1Id: p1Id, player2Id: p2Id });
                    }
                    if(!isValid) return;
                    tourneyCreationState.teams = manualTeams;
                 }

                 const newTournament = {
                    id: Date.now(),
                    name: tourneyCreationState.name,
                    date: tourneyCreationState.date,
                    status: 'inprogress',
                    affectsElo: tourneyCreationState.affectsElo,
                    teams: tourneyCreationState.teams,
                    winnerTeamId: null,
                    rounds: []
                 };

                 const firstRound = [];
                 const shuffledTeams = [...newTournament.teams].sort(() => 0.5 - Math.random());
                 for (let i = 0; i < shuffledTeams.length; i += 2) {
                    firstRound.push({
                        id: `m-${newTournament.id}-0-${i/2}`,
                        teamAId: shuffledTeams[i].id,
                        teamBId: shuffledTeams[i+1].id,
                        winnerTeamId: null,
                        teamA_attackId: null,
                        teamB_attackId: null
                    });
                 }
                 newTournament.rounds.push(firstRound);

                 tournaments.push(newTournament);
                 closeModal(tournamentCreationModal);
                 showMessage(`Torneo "${newTournament.name}" creato con successo!`);
                 saveAndRender();
            }

            function renderTournaments() {
                 inProgressTournaments.innerHTML = '';
                 completedTournaments.innerHTML = '';

                 const inProgress = tournaments.filter(t => t.status === 'inprogress').sort((a,b) => new Date(b.date) - new Date(a.date));
                 const completed = tournaments.filter(t => t.status === 'completed').sort((a,b) => new Date(b.date) - new Date(a.date));

                 if (inProgress.length === 0) inProgressTournaments.innerHTML = '<p class="text-gray-500">Nessun torneo in corso.</p>';
                 if (completed.length === 0) completedTournaments.innerHTML = '<p class="text-gray-500">Nessun torneo completato.</p>';

                 inProgress.forEach(t => inProgressTournaments.appendChild(createTournamentCard(t)));
                 completed.forEach(t => completedTournaments.appendChild(createTournamentCard(t)));
            }

            function createTournamentCard(tournament) {
                const card = document.createElement('div');
                card.className = "p-4 bg-white rounded-lg border shadow-sm hover:shadow-md transition-shadow";

                const winnerInfo = tournament.status === 'completed' ? `üèÜ ${getTeamName(tournament, tournament.winnerTeamId, true)}` : `${tournament.teams.length} Squadre`;

                card.innerHTML = `
                    <div class="flex justify-between items-start">
                        <div class="flex-grow cursor-pointer" data-tournament-id="${tournament.id}">
                            <h4 class="font-bold text-lg text-gray-800">${tournament.name}</h4>
                            <p class="text-sm text-gray-500">${new Date(tournament.date).toLocaleDateString('it-IT')}</p>
                            <div class="text-xs font-bold mt-2">${tournament.affectsElo ? '<span class="p-1 rounded bg-yellow-100 text-yellow-800">ELO ATTIVO</span>' : ''}</div>
                        </div>
                        <div class="text-right flex-shrink-0">
                            <p class="font-semibold text-gray-700">${winnerInfo}</p>
                            <button class="btn-danger p-1 mt-2" style="font-size: 0.7rem;" data-tournament-id="${tournament.id}">
                                <svg xmlns="http://www.w3.org/2000/svg" class="h-4 w-4" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2"><path stroke-linecap="round" stroke-linejoin="round" d="M19 7l-.867 12.142A2 2 0 0116.138 21H7.862a2 2 0 01-1.995-1.858L5 7m5 4v6m4-6v6m1-10V4a1 1 0 00-1-1h-4a1 1 0 00-1 1v3M4 7h16" /></svg>
                            </button>
                        </div>
                    </div>`;
                card.querySelector('.cursor-pointer').addEventListener('click', (e) => openTournamentViewModal(parseInt(e.currentTarget.dataset.tournamentId)));
                card.querySelector('button').addEventListener('click', (e) => confirmDeleteTournament(parseInt(e.currentTarget.dataset.tournamentId)));
                return card;
            }

            function getTeamName(tournament, teamId, short = false) {
                if(!teamId) return 'TBD';
                const team = tournament.teams.find(t => t.id === teamId);
                if (!team) return 'Sconosciuto';
                const p1 = getPlayer(team.player1Id);
                const p2 = getPlayer(team.player2Id);

                if (short && p1 && p2) return `${p1.name.split(' ')[0]} & ${p2.name.split(' ')[0]}`;

                return p1 && p2 ? `${p1.name} & ${p2.name}` : `Squadra ${team.id}`;
            }

            function getTeamNameWithRoles(tournament, teamId, match) {
                if(!teamId || !match) return 'TBD';
                const team = tournament.teams.find(t => t.id === teamId);
                if (!team) return 'Sconosciuto';

                const attackerId = (team.id === match.teamAId) ? match.teamA_attackId : match.teamB_attackId;
                if (!attackerId) return getTeamName(tournament, teamId); // Fallback if roles not set

                const attacker = getPlayer(attackerId);
                const defender = getPlayer(team.player1Id === attackerId ? team.player2Id : team.player1Id);
                return attacker && defender ? `‚öîÔ∏è ${attacker.name} & üõ°Ô∏è ${defender.name}` : `Squadra ${team.id}`;
            }

            function openTournamentViewModal(tournamentId) {
                const tournament = tournaments.find(t => t.id === tournamentId);
                if (!tournament) return;

                tournamentViewHeader.innerHTML = `
                    <div>
                        <h2 class="text-2xl font-bold text-gray-800">${tournament.name}</h2>
                        <p class="text-gray-600">${new Date(tournament.date).toLocaleDateString('it-IT')} - ${tournament.teams.length} squadre</p>
                    </div>
                     <button id="closeTournamentViewModal" class="text-gray-500 text-3xl font-bold hover:text-gray-800">&times;</button>
                `;
                document.getElementById('closeTournamentViewModal').addEventListener('click', () => closeModal(tournamentViewModal));
                renderTournamentBracket(tournament);
                openModal(tournamentViewModal);
            }

            function renderTournamentBracket(tournament) {
                let bracketHTML = '<div class="tournament-bracket">';
                tournament.rounds.forEach((round, roundIndex) => {
                    bracketHTML += `<div class="round" style="min-width: 220px;">`;
                    round.forEach(match => {
                        bracketHTML += `
                         <div class="match" data-match-id="${match.id}" data-tournament-id="${tournament.id}">
                             <div class="team ${match.winnerTeamId === match.teamAId ? 'winner' : ''} ${!match.teamAId ? 'tbd' : ''}">${getTeamNameWithRoles(tournament, match.teamAId, match)}</div>
                             <div class="team ${match.winnerTeamId === match.teamBId ? 'winner' : ''} ${!match.teamBId ? 'tbd' : ''}">${getTeamNameWithRoles(tournament, match.teamBId, match)}</div>
                         </div>
                        `;
                    });
                    bracketHTML += '</div>';
                });
                 bracketHTML += '</div>';
                if(tournament.status === 'completed') {
                    const winnerName = getTeamName(tournament, tournament.winnerTeamId);
                     bracketHTML += `<div class="text-center mt-4 text-2xl font-bold">üèÜ Vincitori: <span class="text-[--accent]">${winnerName}</span></div>`;
                }
                tournamentBracketContainer.innerHTML = bracketHTML;

                 if(tournament.status === 'inprogress') {
                     tournamentBracketContainer.querySelectorAll('.match').forEach(el => {
                        el.addEventListener('click', () => {
                             const matchId = el.dataset.matchId;
                             const tournamentId = el.dataset.tournamentId;
                             openTournamentMatchModal(tournamentId, matchId);
                        });
                     });
                 }
            }

            function openTournamentMatchModal(tournamentId, matchId) {
                const tournament = tournaments.find(t => t.id === parseInt(tournamentId));
                const match = tournament.rounds.flat().find(m => m.id === matchId);
                if(!match || !match.teamAId || !match.teamBId) return;

                currentTournamentMatch = { tournamentId: parseInt(tournamentId), matchId };

                const teamA = tournament.teams.find(t => t.id === match.teamAId);
                const teamB = tournament.teams.find(t => t.id === match.teamBId);
                const pA1 = getPlayer(teamA.player1Id);
                const pA2 = getPlayer(teamA.player2Id);
                const pB1 = getPlayer(teamB.player1Id);
                const pB2 = getPlayer(teamB.player2Id);

                tournamentMatchContent.innerHTML = `
                    <div class="grid grid-cols-1 md:grid-cols-2 gap-6">
                        <div>
                             <h3 class="font-bold text-lg mb-2">${getTeamName(tournament, teamA.id, true)}</h3>
                             <p class="text-sm text-gray-500 mb-2">Chi gioca in attacco?</p>
                             <div class="space-y-2">
                                <label class="flex items-center space-x-3 p-2 border rounded cursor-pointer has-[:checked]:bg-gray-100">
                                    <input type="radio" name="teamA_attacker" value="${pA1.id}" ${match.teamA_attackId === pA1.id ? 'checked' : ''}> <span>${pA1.name}</span>
                                </label>
                                <label class="flex items-center space-x-3 p-2 border rounded cursor-pointer has-[:checked]:bg-gray-100">
                                    <input type="radio" name="teamA_attacker" value="${pA2.id}" ${match.teamA_attackId === pA2.id ? 'checked' : ''}> <span>${pA2.name}</span>
                                </label>
                             </div>
                        </div>
                        <div>
                             <h3 class="font-bold text-lg mb-2">${getTeamName(tournament, teamB.id, true)}</h3>
                             <p class="text-sm text-gray-500 mb-2">Chi gioca in attacco?</p>
                             <div class="space-y-2">
                                <label class="flex items-center space-x-3 p-2 border rounded cursor-pointer has-[:checked]:bg-gray-100">
                                    <input type="radio" name="teamB_attacker" value="${pB1.id}" ${match.teamB_attackId === pB1.id ? 'checked' : ''}> <span>${pB1.name}</span>
                                </label>
                                <label class="flex items-center space-x-3 p-2 border rounded cursor-pointer has-[:checked]:bg-gray-100">
                                    <input type="radio" name="teamB_attacker" value="${pB2.id}" ${match.teamB_attackId === pB2.id ? 'checked' : ''}> <span>${pB2.name}</span>
                                </label>
                             </div>
                        </div>
                    </div>
                    <div class="mt-6">
                         <h3 class="font-bold text-lg mb-2">Chi ha vinto?</h3>
                         <div class="flex items-center space-x-2 rounded-lg bg-gray-100 p-1">
                            <label class="flex-1 text-center cursor-pointer p-2 rounded-md has-[:checked]:bg-yellow-300">
                                <input type="radio" name="tournamentWinner" value="${teamA.id}" class="sr-only" ${match.winnerTeamId === teamA.id ? 'checked' : ''}>
                                <span>${getTeamName(tournament, teamA.id, true)}</span>
                            </label>
                            <label class="flex-1 text-center cursor-pointer p-2 rounded-md has-[:checked]:bg-yellow-300">
                                <input type="radio" name="tournamentWinner" value="${teamB.id}" class="sr-only" ${match.winnerTeamId === teamB.id ? 'checked' : ''}>
                                <span>${getTeamName(tournament, teamB.id, true)}</span>
                            </label>
                        </div>
                    </div>
                `;
                openModal(tournamentMatchModal);
            }

            function confirmTournamentMatchWinner() {
                const { tournamentId, matchId } = currentTournamentMatch;
                const winnerRadio = document.querySelector('input[name="tournamentWinner"]:checked');
                const attackerARadio = document.querySelector('input[name="teamA_attacker"]:checked');
                const attackerBRadio = document.querySelector('input[name="teamB_attacker"]:checked');

                if (!winnerRadio || !attackerARadio || !attackerBRadio) {
                    return showMessage("Devi selezionare un vincitore e i ruoli per entrambe le squadre.", true);
                }

                const winnerTeamId = parseInt(winnerRadio.value);
                const teamA_attackId = parseInt(attackerARadio.value);
                const teamB_attackId = parseInt(attackerBRadio.value);

                recordTournamentMatchWinner(tournamentId, matchId, winnerTeamId, teamA_attackId, teamB_attackId);
                closeModal(tournamentMatchModal);
            }

            function recordTournamentMatchWinner(tournamentId, matchId, winnerTeamId, teamA_attackId, teamB_attackId) {
                const tournament = tournaments.find(t => t.id === tournamentId);
                let match, roundIndex, matchIndex;
                for(let i = 0; i < tournament.rounds.length; i++) {
                    const foundIndex = tournament.rounds[i].findIndex(m => m.id === matchId);
                    if(foundIndex !== -1) {
                        match = tournament.rounds[i][foundIndex];
                        roundIndex = i;
                        matchIndex = foundIndex;
                        break;
                    }
                }

                if (match) {
                    if (match.winnerTeamId && match.winnerTeamId !== winnerTeamId) {
                        resetBracketFrom(tournament, roundIndex, matchIndex);
                    }

                    match.winnerTeamId = winnerTeamId;
                    match.teamA_attackId = teamA_attackId;
                    match.teamB_attackId = teamB_attackId;

                    const currentRound = tournament.rounds[roundIndex];
                    if (currentRound.every(m => m.winnerTeamId)) {
                        const winners = currentRound.map(m => m.winnerTeamId);
                        if (winners.length > 1) {
                            const nextRoundIndex = roundIndex + 1;
                            if (!tournament.rounds[nextRoundIndex]) tournament.rounds[nextRoundIndex] = [];

                            const nextMatchIndex = Math.floor(matchIndex / 2);
                            if (!tournament.rounds[nextRoundIndex][nextMatchIndex]) {
                                 for(let i=0; i < winners.length; i+=2) {
                                    tournament.rounds[nextRoundIndex][i/2] = {
                                        id: `m-${tournament.id}-${nextRoundIndex}-${i/2}`,
                                        teamAId: winners[i], teamBId: winners[i+1],
                                        winnerTeamId: null, teamA_attackId: null, teamB_attackId: null
                                    };
                                }
                            }
                        } else {
                            tournament.status = 'completed';
                            tournament.winnerTeamId = winners[0];
                            showMessage(`Torneo "${tournament.name}" completato!`);
                        }
                    }

                    recalculateAllElos();
                    saveAndRender();
                    renderTournamentBracket(tournament);
                }
            }

            function resetBracketFrom(tournament, roundIndex, matchIndex) {
                 for (let r = roundIndex; r < tournament.rounds.length; r++) {
                    const nextRoundIndex = r + 1;
                    if (!tournament.rounds[nextRoundIndex]) continue;

                    const nextMatchIndex = Math.floor(matchIndex / 2);
                    const nextMatch = tournament.rounds[nextRoundIndex][nextMatchIndex];

                    if (nextMatch) {
                        if (nextMatch.winnerTeamId) {
                            resetBracketFrom(tournament, nextRoundIndex, nextMatchIndex);
                        }
                        nextMatch.winnerTeamId = null;
                        nextMatch.teamA_attackId = null;
                        nextMatch.teamB_attackId = null;

                        if (matchIndex % 2 === 0) nextMatch.teamAId = null;
                        else nextMatch.teamBId = null;
                    }
                    matchIndex = nextMatchIndex;
                 }
                 if (tournament.status === 'completed') {
                    tournament.status = 'inprogress';
                    tournament.winnerTeamId = null;
                 }
            }

            function confirmDeleteTournament(id) {
                const tournament = tournaments.find(t => t.id === id);
                if(!tournament) return;
                tournamentIdToDelete = id;
                tournamentDeleteSummaryText.textContent = `Sei sicuro di voler eliminare il torneo "${tournament.name}"? L'azione √® irreversibile e ricalcoler√† tutti i punteggi ELO (se il torneo li influenzava).`;
                openModal(confirmDeleteTournamentModal);
            }

            function deleteTournament() {
                if(tournamentIdToDelete === null) return;
                tournaments = tournaments.filter(t => t.id !== tournamentIdToDelete);
                recalculateAllElos();
                saveAndRender();
                closeModal(confirmDeleteTournamentModal);
                showMessage("Torneo eliminato con successo.");
                tournamentIdToDelete = null;
            }


            // --- Inizializzazione ---
            function init() {
                // Close button for the pre-match assistant modal
                const closePreMatchAssistantBtn = document.getElementById('closePreMatchAssistantBtn');
                if (closePreMatchAssistantBtn) {
                    closePreMatchAssistantBtn.addEventListener('click', closePreMatchAssistant);
                }

                if ('serviceWorker' in navigator) {
                    window.addEventListener('load', () => {
                        navigator.serviceWorker.register('/service-worker.js').catch(err => console.log('SW reg failed: ', err));
                    });
                }

                geminiApiKeyInput.addEventListener('change', (e) => {
                    const key = e.target.value.trim();
                    if(key) {
                        localStorage.setItem('geminiApiKey', encryptKey(key));
                    } else {
                        localStorage.removeItem('geminiApiKey');
                    }
                });

                [scoreAInput, scoreBInput].forEach(input => {
                    input.addEventListener('input', () => {
                        const scoreA = parseInt(scoreAInput.value);
                        const scoreB = parseInt(scoreBInput.value);
                        if (isNaN(scoreA) || isNaN(scoreB)) return;

                        if (scoreA > scoreB) {
                            document.querySelector('input[name="winner"][value="A"]').checked = true;
                        } else if (scoreB > scoreA) {
                            document.querySelector('input[name="winner"][value="B"]').checked = true;
                        }
                    });
                });

                matchDateInput.value = new Date().toISOString().split('T')[0];
                addPlayerBtn.addEventListener('click', addPlayer);
                playerNameInput.addEventListener('keypress', e => { if (e.key === 'Enter') addPlayer(); });
                recordMatchBtn.addEventListener('click', preRecordMatch);

                const setupSortButton = (btn, icon, sortBy) => {
                    btn.addEventListener('click', () => {
                        if (leaderboardSort.by === sortBy) leaderboardSort.order = leaderboardSort.order === 'desc' ? 'asc' : 'desc';
                        else leaderboardSort = { by: sortBy, order: 'asc' };

                        (sortBy === 'elo' ? nameSortIcon : eloSortIcon).style.transform = '';
                        icon.style.transform = leaderboardSort.order === 'desc' ? 'rotate(180deg)' : '';
                        if (sortBy === 'elo' && leaderboardSort.order === 'desc') icon.style.transform = '';

                        const isPeriod = document.querySelector('input[name="rankType"]:checked').value === 'period';
                        if(isPeriod) handleLeaderboardFilter();
                        else renderPlayers();
                    });
                };
                setupSortButton(nameSortBtn, nameSortIcon, 'name');
                setupSortButton(eloSortBtn, eloSortIcon, 'elo');

                matchSortSelect.addEventListener('change', (e) => {
                    matchHistorySort = e.target.value;
                    renderMatches();
                });

                allSelects.forEach(sel => sel.addEventListener('change', updateTeamEloDisplays));
                teamAssistantBtn.addEventListener('click', openTeamAssistantModal);

                // --- Event Listeners per Modals ---
                closeHistoryModalBtn.addEventListener('click', () => closeModal(historyModal));
                historyModal.addEventListener('click', e => { if(e.target === historyModal) closeModal(historyModal); });
                historyFilterBtn.addEventListener('click', () => {
                    updateAllPlayerData();
                    getGeminiAnalysisForPlayer();
                });
                Object.values(playerAnalysisTabs).forEach(tab => tab.addEventListener('click', () => switchTab(tab.id.replace('tab', '').toLowerCase())));
                playerMatchSortSelect.addEventListener('change', renderPlayerMatchHistory);

                comparisonTabs.forEach(tab => tab.addEventListener('click', (e) => {
                    comparisonTabs.forEach(t => t.classList.remove('active'));
                    e.target.classList.add('active');
                    comparisonMode = e.target.dataset.tab;
                    synergyControls.classList.toggle('hidden', comparisonMode !== 'synergy');
                    rolesControls.classList.toggle('hidden', comparisonMode !== 'roles');
                    playerListTitle.textContent = comparisonMode === 'synergy' ? "Seleziona Compagni da Confrontare" : "Seleziona Giocatori";
                }));
                compareBtn.addEventListener('click', handleComparison);
                closeComparisonModalBtn.addEventListener('click', () => closeModal(comparisonModal));

                assistantTabs.forEach(tab => tab.addEventListener('click', (e) => {
                    assistantTabs.forEach(t => t.classList.remove('active'));
                    e.target.classList.add('active');
                    const mode = e.target.dataset.tab;
                    assistantOpponentsContent.classList.toggle('hidden', mode !== 'opponents');
                    assistantPartnersContent.classList.toggle('hidden', mode !== 'partners');
                    if (mode === 'opponents') showOpponentProposals();
                    else renderPartnerFinder();
                }));

                partnerFinderPlayer.addEventListener('change', renderPartnerFinder);
                partnerFinderRole.addEventListener('change', renderPartnerFinder);
                partnerFinderStartDate.addEventListener('change', renderPartnerFinder);
                partnerFinderEndDate.addEventListener('change', renderPartnerFinder);

                partnerList.addEventListener('click', (e) => {
                    const card = e.target.closest('[data-player-id]');
                    if(card) {
                        const {playerId, playerRole, partnerId, partnerRole} = card.dataset;
                        teamASelects[playerRole].value = playerId;
                        teamASelects[partnerRole].value = partnerId;
                        updateTeamEloDisplays();
                        closeModal(teamAssistantModal);
                    }
                });

                closeTeamAssistantModal.addEventListener('click', () => closeModal(teamAssistantModal));
                assistantOpponentsContent.addEventListener('click', (e) => {
                    const card = e.target.closest('[data-attack-id]');
                    if (card) {
                        const isTeamAFilled = teamASelects.attack.value && teamASelects.defense.value;
                        const targetSelects = isTeamAFilled ? teamBSelects : teamASelects;

                        targetSelects.attack.value = card.dataset.attackId;
                        targetSelects.defense.value = card.dataset.defenseId;
                        updateTeamEloDisplays();
                        closeModal(teamAssistantModal);
                    }
                });
                cancelRecordBtn.addEventListener('click', () => closeModal(confirmRecordModal));
                confirmRecordBtn.addEventListener('click', () => { recordMatch(); closeModal(confirmRecordModal); });
                cancelDeleteBtn.addEventListener('click', () => closeModal(confirmDeleteModal));
                confirmDeleteBtn.addEventListener('click', () => {
                    if (matchIdToDelete) {
                        deleteMatch(matchIdToDelete);
                        recalculateAllElos();
                        saveAndRender();
                        showMessage("Partita eliminata.");
                    }
                    closeModal(confirmDeleteModal);
                    matchIdToDelete = null;
                });
                cancelPlayerDeleteBtn.addEventListener('click', () => {
                    closeModal(confirmPlayerDeleteModal);
                    playerIdToDelete = null;
                });
                confirmPlayerDeleteBtn.addEventListener('click', deletePlayer);
                
                [eloInfoBtnA, eloInfoBtnB].forEach(btn => btn.addEventListener('click', getEloExplanation));
                document.getElementById('closeEloExplanationModal').addEventListener('click', () => closeModal(eloExplanationModal));

                bulkDeleteBtn.addEventListener('click', handleBulkDeletePreview);
                cancelBulkDeleteBtn.addEventListener('click', () => closeModal(confirmBulkDeleteModal));
                confirmBulkDeleteBtn.addEventListener('click', () => {
                    matches = matches.filter(m => !matchesToDeleteIds.includes(m.id));
                    recalculateAllElos();
                    saveAndRender();
                    closeModal(confirmBulkDeleteModal);
                    showMessage(`${matchesToDeleteIds.length} partite eliminate.`);
                    matchesToDeleteIds = [];
                });
                linkFileBtn.addEventListener('click', linkFile);
                exportBtn.addEventListener('click', exportData);
                importBtn.addEventListener('click', () => importFileInput.click());
                importFileInput.addEventListener('change', importData);

                // Leaderboard filter logic
                rankTypeRadios.forEach(radio => radio.addEventListener('change', (e) => {
                    const isPeriod = e.target.value === 'period';
                    leaderboardDateFilters.classList.toggle('hidden', !isPeriod);
                    leaderboardCommentaryContainer.classList.add('hidden');
                    if (!isPeriod) {
                        renderPlayers();
                    }
                }));
                leaderboardFilterBtn.addEventListener('click', handleLeaderboardFilter);

                matchHistoryFilterBtn.addEventListener('click', renderMatches);
                matchHistoryResetBtn.addEventListener('click', () => {
                    matchHistoryStartDate.value = '';
                    matchHistoryEndDate.value = '';
                    renderMatches();
                });

                invertRolesABtn.addEventListener('click', () => {
                    const temp = teamASelects.attack.value;
                    teamASelects.attack.value = teamASelects.defense.value;
                    teamASelects.defense.value = temp;
                    updateTeamEloDisplays();
                });

                invertRolesBBtn.addEventListener('click', () => {
                    const temp = teamBSelects.attack.value;
                    teamBSelects.attack.value = teamBSelects.defense.value;
                    teamBSelects.defense.value = temp;
                    updateTeamEloDisplays();
                });

                invertTeamsBtn.addEventListener('click', () => {
                    const tempA_att = teamASelects.attack.value;
                    const tempA_def = teamASelects.defense.value;

                    teamASelects.attack.value = teamBSelects.attack.value;
                    teamASelects.defense.value = teamBSelects.defense.value;

                    teamBSelects.attack.value = tempA_att;
                    teamBSelects.defense.value = tempA_def;

                    updateTeamEloDisplays();
                });

                // Tournament Listeners
                createNewTournamentBtn.addEventListener('click', openTournamentCreationModal);
                closeTournamentCreationModal.addEventListener('click', () => closeModal(tournamentCreationModal));
                cancelTournamentMatch.addEventListener('click', () => closeModal(tournamentMatchModal));
                confirmTournamentMatch.addEventListener('click', confirmTournamentMatchWinner);
                cancelTournamentDeleteBtn.addEventListener('click', () => { closeModal(confirmDeleteTournamentModal); tournamentIdToDelete = null; });
                confirmTournamentDeleteBtn.addEventListener('click', deleteTournament);
                setupTournamentCreationWizard();
                
                // Listener per i commenti AI
                const commentaryButtonHandler = async (e) => {
                    const commentaryBtn = e.target.closest('.generate-commentary-btn');
                    if (commentaryBtn) {
                        e.stopPropagation(); // Evita di triggerare l'accordion
                        const matchId = parseInt(commentaryBtn.dataset.matchId);
                        commentaryBtn.disabled = true;
                        commentaryBtn.textContent = 'Generando...';
                        await generateDualMatchCommentaries(matchId);
                        // The saveAndRender() inside generateDualMatchCommentaries will refresh the UI.
                        commentaryBtn.disabled = false;
                        commentaryBtn.textContent = 'Analisi AI';
                    }
                };

                matchHistoryContainer.addEventListener('click', commentaryButtonHandler);
                playerMatchHistoryContainer.addEventListener('click', commentaryButtonHandler);

                setupAccordions();
                loadFromStorage();
                recalculateAllElos();
                render();

                showPreMatchAssistant();

                const allMatchDates = getAllHistoricalMatches().map(m => m.date).sort();
                if (allMatchDates.length) {
                    const firstDate = allMatchDates[0], lastDate = allMatchDates[allMatchDates.length - 1];
                    [comparisonStartDateInput, bulkDeleteStartDateInput, leaderboardStartDate, matchHistoryStartDate, partnerFinderStartDate].forEach(i => i.value = firstDate);
                    [comparisonEndDateInput, bulkDeleteEndDateInput, leaderboardEndDate, matchHistoryEndDate, partnerFinderEndDate].forEach(i => i.value = lastDate);
                }
            }
             // --- Funzioni Chat ---
            function getChatContext() {
                const rankedPlayers = players.filter(p => p.gamesPlayed > 0).sort((a,b) => b.elo - a.elo);
                const context = {
                    totalPlayers: players.length,
                    totalMatches: matches.length,
                    totalTournaments: tournaments.length,
                    leaderboardTop5: rankedPlayers.slice(0, 5).map(p => ({ name: p.name, elo: Math.round(p.elo) })),
                    mostGamesPlayer: players.sort((a,b) => b.gamesPlayed - a.gamesPlayed)[0]?.name,
                };
                return `Contesto attuale dei dati dell'applicazione (in formato JSON, non mostrarlo all'utente): ${JSON.stringify(context)}`;
            }

            async function handleChatSubmit() {
                const query = geminiChatInput.value.trim();
                if (!query) return;

                addChatMessage('user', query);
                geminiChatInput.value = '';
                geminiChatSendBtn.disabled = true;
                addChatMessage('assistant', '<p class="animate-pulse">L\'assistente sta pensando...</p>', true);

                const contextPrompt = getChatContext();
                const fullPrompt = `${contextPrompt}\n\nL'utente chiede: "${query}".\n\nRispondi alla domanda dell'utente in modo conciso e amichevole, basandoti sui dati di contesto forniti. Se la domanda non √® pertinente ai dati, rispondi che puoi solo rispondere a domande relative alle statistiche di calcio balilla dell'app.`;

                const response = await callGeminiAPI(fullPrompt);

                const lastMessage = geminiChatMessages.querySelector('.assistant-message:last-child .message-content');
                if (lastMessage) {
                    lastMessage.innerHTML = response ? response.replace(/\n/g, '<br>') : "Si √® verificato un errore. Riprova.";
                }
                geminiChatSendBtn.disabled = false;
            }

            function addChatMessage(role, content, isHtml = false) {
                const messageDiv = document.createElement('div');
                messageDiv.className = `chat-message ${role}-message`;

                const icon = role === 'user' ? 'üë§' : 'ü§ñ';

                messageDiv.innerHTML = `
                    <div class="flex items-start gap-3">
                        <span class="text-2xl">${icon}</span>
                        <div class="message-content p-3 rounded-lg w-full ${role === 'user' ? 'bg-blue-100' : 'bg-gray-100'}">
                            ${isHtml ? content : content}
                        </div>
                    </div>
                `;
                geminiChatMessages.appendChild(messageDiv);
                geminiChatMessages.scrollTop = geminiChatMessages.scrollHeight;
            }


            function init() {
                // ... (existing init code)

                // Add chat listeners
                geminiChatFab.addEventListener('click', () => {
                    openModal(geminiChatModal);
                    if (geminiChatMessages.children.length === 0) {
                        addChatMessage('assistant', "Ciao! Sono l'assistente dati. Chiedimi qualsiasi cosa sulle statistiche dei giocatori e delle partite.");
                    }
                });
                closeGeminiChatModal.addEventListener('click', () => closeModal(geminiChatModal));
                geminiChatSendBtn.addEventListener('click', handleChatSubmit);
                geminiChatInput.addEventListener('keypress', e => { if(e.key === 'Enter') handleChatSubmit(); });

                // ... (the rest of the init function)
                setupAccordions();
                // ...
            }
            init();
        });
    </script>
</body>
</html>
